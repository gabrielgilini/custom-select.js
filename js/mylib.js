
/*

 Generated by My Library Builder v1.0 (http://www.cinsoft.net/mylib-builder.asp)

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 Modified copies of the Software must be renamed.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.

*/
// Fri, 2 Sep 2011 03:29:08 UTC
// My Library (http://www.cinsoft.net/mylib.html)
// Copyright (c) 2007-2010 by David Mark. All Rights Reserved.
var API, global = this;
API = API || {};

(function() {
  var doc, html;

  // Feature testing support

  var reFeaturedMethod = new RegExp('^(function|object)$', 'i');

  // Test for properties of host objects that are never callable (e.g. document nodes, elements)

  var isRealObjectProperty = function(o, p) {
    return !!(typeof o[p] == 'object' && o[p]);
  };

  API.isRealObjectProperty = isRealObjectProperty;

  var isHostMethod = function(o, m) {
    var t = typeof o[m];
    return !!((reFeaturedMethod.test(t) && o[m]) || t == 'unknown');
  };

  API.isHostMethod = isHostMethod;

  var isHostObjectProperty = function(o, p) {
    var t = typeof o[p];
    return !!(reFeaturedMethod.test(t) && o[p]);
  };

  API.isHostObjectProperty = isHostObjectProperty;

  // Test multiple API properties

  var areFeatures = function() {
    var i = arguments.length;
    while (i--) {
      if (!API[arguments[i]]) {
        return false;
      }
    }
    return true;
  };

  API.areFeatures = areFeatures;

  // for-in filter

  var isOwnProperty = function(o, p) {
    var prop = o.constructor.prototype[p];
    return typeof prop == 'undefined' || prop !== o[p];
  };

  API.isOwnProperty = isOwnProperty;

  var canCall = !!Function.prototype.call;

  var bind, bindDeferred;

  if (canCall) {
    bind = function(fn, context) {
      var prependArgs = Array.prototype.slice.call(arguments, 2);

      if (prependArgs.length) {
        return function() {
          fn.apply(context, Array.prototype.concat.apply(prependArgs, arguments));
        };
      }
      return function() {
        fn.apply(context, arguments);
      };
    };

    bindDeferred = function(fn, context, delay) {
      var timeout;

      fn = bind.apply(this, [fn, context].concat(Array.prototype.slice(arguments, 3)));
      return function() {
        if (timeout) {
          global.clearTimeout(timeout);
          timeout = 0;
        }
        var args = Array.prototype.slice(arguments, 0);
        timeout = global.setTimeout(function() {
          fn.apply(this, args)
        }, delay);
      };
    };

    API.bind = bind;
    API.bindDeferred = bindDeferred;
  }

  if (isRealObjectProperty(this, 'document')) {
    doc = this.document;
  }

  // Converts array-like objects to arrays
  function toArray(o) {
    var a = [];
    var i = o.length;
    a.length = i;
    while (i--) { a[i] = o[i]; }
    return a;
  }

  API.toArray = toArray;

  var getDocumentWindow;

  var elementUniqueId = (function() {
    var it = 0;
    return function(el) { return el.uniqueID || (el.uniqueID = '_api' + it++); };
  })();

  API.elementUniqueId = elementUniqueId;

  var attachDocumentReadyListener, bReady, documentReady, documentReadyListener, readyListeners = [];
  var canAddDocumentReadyListener, canAddWindowLoadListener, canAttachWindowLoadListener;

  if (doc) {
    canAddDocumentReadyListener = isHostMethod(doc, 'addEventListener');
    canAddWindowLoadListener = isHostMethod(this, 'addEventListener');
    canAttachWindowLoadListener = isHostMethod(this, 'attachEvent');

    //if (canAddDocumentReadyListener || canAddWindowLoadListener || canAttachWindowLoadListener) {
      bReady = false;
      documentReady = function() { return bReady; };
      documentReadyListener = function(e) {
        if (!bReady) {
          bReady = true;
          var i = readyListeners.length;
          var m = i - 1;
          // NOTE: e may be undefined (not always called by event handler)
          while (i--) { readyListeners[m - i](e); }
        }
      };

      attachDocumentReadyListener = function(fn, docNode) {
        var addListeners = function(win) {
          if (canAddDocumentReadyListener) {
            docNode.addEventListener('DOMContentLoaded', documentReadyListener, false);
          }
          if (canAddWindowLoadListener) {
            global.addEventListener('load', documentReadyListener, false);
          } else if (canAttachWindowLoadListener) {
            global.attachEvent('onload', documentReadyListener);
          } else {
            var oldOnLoad = global.onload;
            global.onload = function(e) { if (oldOnLoad) { oldOnLoad(e); } documentReadyListener(); };
          }
        };
        docNode = docNode || global.document;
        if (docNode == global.document) {
          if (!readyListeners.length) {
            addListeners(global);
          }
          readyListeners[readyListeners.length] = fn;
          return true;
        }
        if (getDocumentWindow) {
          var win = getDocumentWindow(docNode);
          if (win) {
            addListeners(win);
            return true;
          }
        }
        return false;
      };

      API.documentReady = documentReady;
      API.documentReadyListener = documentReadyListener;
      API.attachDocumentReadyListener = attachDocumentReadyListener;
    //}
  }

  var hasAttribute;

  var createElement, isXmlParseMode;

  // DOM section

  var commonElementsByTagName, disableElements, emptyNode, getAttribute, getAttributeProperty, getChildren, getEBI, getEBTN, getHeadElement, getFrameById, getIFrameDocument, removeAttribute, reUserBoolean, reURI, reSpan;
  var attributeAliases = {'for':'htmlFor', accesskey:'accessKey', codebase:'codeBase', frameborder:'frameBorder', framespacing:'frameSpacing', nowrap:'noWrap', maxlength:'maxLength', 'class':'className', readonly:'readOnly', longdesc:'longDesc', tabindex:'tabIndex', rowspan:'rowSpan', colspan:'colSpan', ismap:'isMap', usemap:'useMap', cellpadding:'cellPadding', cellspacing:'cellSpacing'};
  var attributesBad, numericAttributesBad, encTypeAttributeBad, valueHasAttributeBad;
  var camelize, reNotEmpty, reCamel = new RegExp('([^-]*)-(.)(.*)');

  var addElementText, getElementText, setElementText, trim;


  if (doc) {
    getDocumentWindow = (function() {
      if (isRealObjectProperty(doc, 'parentWindow')) {
        return function(docNode) {
          return (docNode || global.document).parentWindow;
        };
      }
      if (isRealObjectProperty(doc, 'defaultView') && doc.defaultView == this) { // defaultView is not always window/global object (e.g. IceBrowser, Safari 2)
        return function(docNode) {
          return (docNode || global.document).defaultView;
        };
      }
      if (isRealObjectProperty(doc, '__parent__')) { // IceBrowser
        return function(docNode) {
          return (docNode || global.document).__parent__;
        };
      }
    })();
  }

  API.getDocumentWindow = getDocumentWindow;

  var purgeListeners;

  function getElementSize(el) { return [el.offsetHeight || 0, el.offsetWidth || 0, el.clientHeight || 0, el.clientWidth || 0, el.scrollHeight || 0, el.scrollWidth || 0]; }

  API.getElementSize = getElementSize;


  API.emptyNode = emptyNode = function(node) {
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
  };

  function getElementDocument(el) {
    if (el.ownerDocument) {
      return el.ownerDocument;
    }
    if (el.parentNode) {
      while (el.parentNode) {
        el = el.parentNode;
      }
      if (el.nodeType == 9 || (!el.nodeType && !el.tagName)) {
        return el;
      }
      // FIXME: This is stupid, untangle attachListenerFactory
      if (el.document && typeof el.tagName == 'string') {
        return el.document;
      }
    }
    return null;
  }

  API.getElementDocument = getElementDocument;


  function getElementParentElement(el) {
    return (el.parentNode && (el.parentNode.tagName || el.parentNode.nodeType == 1))?el.parentNode:(el.parentElement || null);
  }

  API.getElementParentElement = getElementParentElement;

  function getElementNodeName(el) {
    var nn = (el.tagName || el.nodeName).toLowerCase();
    return (!nn.indexOf('html:'))?nn.substring(5):nn;
  }

  API.getElementNodeName = getElementNodeName;

  function elementCanHaveChildren(el) {
    return typeof el.canHaveChildren == 'undefined' || el.canHaveChildren;
  }

  var canAdjustStyle, isStyleCapable, iStyle, styles;

  var allElements, getAnElement, getHtmlElement, isDescendant;
  if (doc) {

    if (isHostObjectProperty(doc, 'all')) {
      allElements = (function() {
        return function(el, bFilter) {
          var i, a, n, r;
          if (!bFilter) {
            return el.all;
          }
          else {
            a = toArray(el.all);
            i = a.length;
            r = [];

            while (i--) {
              // Code duplicated for performance
              n = a[i];
              if ((n.nodeType == 1 && n.tagName != '!') || (!n.nodeType && n.tagName)) {
                r[r.length] = a[i];
              }
            }
            return r.reverse();
          }
        };
      })();
    }

    // Returns the HTML element by default or optionally the first element it finds.
    getHtmlElement = function(docNode, bAnyElement) {
      var h, all;
      docNode = docNode || global.document;
      h = isRealObjectProperty(docNode, 'documentElement')?docNode.documentElement:((typeof getEBTN == 'function')?getEBTN('html', docNode)[0]:null);
      if (!h && allElements) {
        all = allElements(docNode); // Don't bother to filter for this
        h = all[(all[0].tagName == '!')?1:0];
        if (h && !bAnyElement && h.tagName.toLowerCase() != 'html') { h = null; }
      }
      return h;
    };

    API.getHtmlElement = getHtmlElement;

    // Returns any element
    getAnElement = function(docNode) {
      return getHtmlElement(docNode, true);
    };

    API.getAnElement = getAnElement;

    html = getAnElement();
    if (html && typeof html.parentNode != 'undefined') {
      isDescendant = function(el, elDescendant) {
        var parent = elDescendant.parentNode;
        while (parent && parent != el) {
          parent = parent.parentNode;
        }
        return parent == el;
      };
    }

    API.isDescendant = isDescendant;
  }

  if (doc) {

    attributesBad = !!(html && isHostMethod(html, 'getAttribute') && html.getAttribute('style') && typeof html.getAttribute('style') == 'object');
    if (!attributesBad && isHostMethod(doc, 'createElement')) {

      // TODO: Rename to missingAttributesBad--specs disagree with established quasi-standards (return null for missing attributes)

      numericAttributesBad = (function() {
        var el = doc.createElement('td');
        if (el && isHostMethod(el, 'getAttribute')) {
          return el.getAttribute('colspan') !== null;
        }
      })();

      encTypeAttributeBad = (function() {
        var el = doc.createElement('form');
        el.setAttribute('enctype', 'application/x-www-form-urlencoded');
        el.removeAttribute('enctype');
        return el.getAttribute('enctype') !== null;
      })();

      valueHasAttributeBad = (function() {
        var el = doc.createElement('input');
        el.type = 'checkbox';
        el.checked = true;
        return (typeof el.hasAttribute != 'undefined' && el.hasAttribute('value'));
      })();
    }
    hasAttribute = (function() {
      var attributeSpecified, v;
      if (html && isHostMethod(html, 'hasAttribute')) {
        return function(el, name) {
		var re, nameLower = name.toLowerCase();
		var alias = attributeAliases[nameLower];
		var valueType = typeof el[alias];

		if (numericAttributesBad) {
			if (reSpan.test(nameLower)) {

				// Some agents (e.g. Blackberry browser) return '' for missing span attributes

				if (!el.getAttribute(nameLower)) {
					return false;
				}

				// Check outer HTML as last resort (IE8 standards mode known to take this fork)

				if (typeof el.outerHTML == 'string') {
					re = new RegExp('^[^>]*\\s+' + name + '=([\'"])?\\w+\\1?', 'i');
					return re.test(el.outerHTML);
				}
			} else if (valueType == 'number' && !el.getAttribute(nameLower)) {
				return false;
			} else if (reUserBoolean.test(nameLower)) {
				var b = el['default' + nameLower.substring(0, 1).toUpperCase() + name.substring(1)];
				if (typeof b == 'boolean') { // XML documents will not feature these boolean properties
					return b;
				}
			}
		}
		if (encTypeAttributeBad && nameLower == 'enctype') {
			// TODO: Consolidate
			if (typeof el.outerHTML == 'string') {
				re = new RegExp('^[^>]*\\s+' + name + '=([\'"])?\\w+\\1?', 'i');
				return re.test(el.outerHTML);
			}
			return !!(el.attributes.enctype && el.attributes.enctype.specified);
		}
		if (valueHasAttributeBad && nameLower == 'value' && typeof el.outerHTML == 'string') {
			re = new RegExp('^[^>]*\\s+value=([\'"])?\\w*\\1?', 'i');
			return re.test(el.outerHTML);
		}
		return el.hasAttribute(name);
        };
      }
      if (html && isHostMethod(html, 'attributes')) {
        attributeSpecified = function(el, name) {
          v = el.attributes[name];
          return !!(v && v.specified);
        };
        if (attributesBad) {
          return function(el, name) {

		// MSXML document

		var doc = arguments[2] || getElementDocument(el);
		if (doc && typeof(doc.selectNodes) != 'undefined') { return attributeSpecified(el, name); } // XML document
		var value, re, nameLower = name.toLowerCase();

		// NOTE: encType is a non-standard alias found only in broken MSHTML DOM's (only applies to attributes collection)

		var alias = nameLower == 'enctype' ? 'encType' : attributeAliases[nameLower];

		if (alias && alias.toLowerCase() == nameLower) {
			name = alias;
		}

		// NOTE: Broken MSHTML DOM is case-sensitive here with custom attributes

		if (el.attributes) {
			value = el.attributes[name] || el.attributes[nameLower];
		}
		if (value) {
			if (reSpan.test(nameLower) && value.value == '1') {
				re = new RegExp('^[^>]*\\s+' + name + '=([\'"])?\\w*\\1?', 'i');
				return re.test(el.outerHTML);
			}

			// NOTE: enctype and value attributes never specified

			if (value.specified) {
				return true;
			}

			if (typeof el[name] == 'boolean') {
				if (reUserBoolean.test(nameLower)) {
					return el['default' + nameLower.substring(0, 1).toUpperCase() + name.substring(1)];
				}
				return el[name];
			}

			// TODO: Consolidate

			if (nameLower == 'value' && ((/^input$/i.test(el.tagName) && /^text$/i.test(el.type)))) {
				return !!(el.defaultValue || el.defaultValue != el.value);
			}

			// TODO: Consolidate

			if (/^(enctype|value)$/.test(nameLower) && typeof el.outerHTML == 'string') {
				re = new RegExp('^[^>]*\\s+' + name + '=([\'"])?\\w*\\1?', 'i');
				return re.test(el.outerHTML);
			}
		}
		return false;
          };
        }
        return attributeSpecified;
      }
    })();

    API.hasAttribute = hasAttribute;


    disableElements = function() {
      var b, i = arguments.length;
      if (i > 1 && typeof arguments[i - 1] == 'boolean') {
        b = arguments[i - 1];
        i--;
      }
      while (i--) { arguments[i].disabled = !b; }
    };

    API.disableElements = disableElements;

    getEBI = (function() {
      function idCheck(el, id) {
        return (el && el.id == id)?el:null;
      }
      if (isHostMethod(doc, 'getElementById')) {
        return function(id, docNode) { return idCheck((docNode || global.document).getElementById(id), id); };
      }
      if (isHostMethod(doc, 'all')) {
        return function(id, docNode) { return idCheck((docNode || global.document).all[id], id); };
      }
    })();

    API.getEBI = getEBI;

    getFrameById = function(id, win) {
      if (!win) {
        win = global;
      }
      var frame = win.frames[id];
      if (!frame && getEBI) {
        frame = getEBI(id, win.document);
        if (frame && isHostObjectProperty(frame, 'contentWindow')) {
          frame = frame.contentWindow;
        } else {
          frame = null;
        }
      }
      return frame;
    };

    API.getFrameById = getFrameById;

    getIFrameDocument = function(el, win) {
      return el.contentDocument || (el.contentWindow || getFrameById(el.name, win) || el).document || null;
    };

    API.getIFrameDocument = getIFrameDocument;

    commonElementsByTagName = (function() {
      if (allElements) {
        return function (el, t) {
          return(t == '*' && el.all)?allElements(el, true):el.getElementsByTagName(t);
        };
      }
      return function (el, t) { return el.getElementsByTagName(t); };
    })();

    // Returns an array or array-like host object.
    getEBTN = (function() {
      var els;
      if (isHostMethod(doc, 'getElementsByTagName')) {
        els = doc.getElementsByTagName('*');      // Test "*" parameter, which fails in some agents (e.g. IE5, Safari 1)
        if (els && (els.length || allElements)) { // Need document.all as fallback for agents that cannot handle a "*" parameter (Safari 1 is excluded by this test.)
          return function(t, docNode) {
            return commonElementsByTagName(docNode || global.document, t);
          };
        }
      }
      if (isHostObjectProperty(doc, 'all') && isHostMethod(doc.all, 'tags')) {
        return function(t, docNode) {
          return (docNode || global.document).all.tags(t);
        };
      }
    })();

    API.getEBTN = getEBTN;

    if (getEBTN) {
      getHeadElement = function(docNode) {
        return getEBTN('head', docNode || global.document)[0] || null;
      };
    }

    API.getHeadElement = getHeadElement;

    camelize = function(name) {
      if (reCamel.test(name)) {
        var m = name.match(reCamel);
        return (m)?([m[1], m[2].toUpperCase(), m[3]].join('')):name;
      }
      return name;
    };

    if (html && isHostMethod(html, 'removeAttribute')) {
      removeAttribute = function(node, name) {
        var nameLower = name.toLowerCase();
        var alias = attributeAliases[nameLower];

        if (attributesBad) {
          // NOTE: encType alias does not apply here

          if (alias && alias.toLowerCase() == nameLower) {
            name = alias;
          } else {
            name = camelize(name);
          }
        }
        alias = alias || nameLower;
        if (typeof node[alias] == 'boolean') {
          node[alias] = false;
        } else {
          node.removeAttribute(name);
        }
      };
    }

    reUserBoolean = new RegExp('^(checked|selected)$');
    reSpan = new RegExp('^(row|col)?span$');
    reURI = new RegExp('^(href|src|data|usemap|longdesc|codebase|classid|profile|cite)$');

    API.removeAttribute = removeAttribute;

    // Returns null if attribute is not present

    getAttribute = (function() {
      var att, alias, nameC, originalName, nn, reEvent, reNewLine, reFunction;

      if (html && isHostMethod(html, 'getAttribute') && hasAttribute) {
        if (attributesBad) {
            reEvent = new RegExp('^on');
            reNewLine = new RegExp('[\\n\\r]', 'g');
            reFunction = new RegExp('^function [^\\(]*\\(\\) *{(.*)} *$');

            return function(el, name) { // Optional third argument speeds up by skipping getElementDocument
              var doc = arguments[2] || getElementDocument(el);
              if (doc && typeof(doc.selectNodes) != 'undefined') { return el.getAttribute(name); } // XML document
              if (hasAttribute(el, name)) {
                originalName = name;
                name = name.toLowerCase();
                alias = attributeAliases[name];
                if (!alias) {
                  if (reUserBoolean.test(name)) {
                    return el['default' + name.substring(0, 1).toUpperCase() + name.substring(1)] ? '' : null;
                  }
                  if (name == 'style') { return (el.style)?(el.style.cssText || ''):''; }
                  if (reURI.test(name)) { return el.getAttribute(name, 2); }
                  if (reEvent.test(name) && el[name]) {
                    att = el[name].toString();
                    if (att) {
                      att = att.replace(reNewLine, '');
                      if (reFunction.test(att)) { return att.replace(reFunction, '$1'); }
                    }
                    return null;
                  }
                  nn = el.tagName.toLowerCase();
                  if (nn == 'select' && name == 'type') { return null; }
                  if (nn == 'form' && el.getAttributeNode) {
                    att = el.getAttributeNode(name);
                    return (att && att.nodeValue)?att.nodeValue:null;
                  }
                }
                nameC = camelize(alias || name);
                if (typeof el[nameC] == 'unknown') {
                  return '[unknown]';
                } else {
                  if (reURI.test(nameC)) {
                    return el.getAttribute(nameC, 2);
                  }
                  if (typeof el[nameC] == 'boolean') {
                    return (el[nameC])?'':null;
                  }
                  if (typeof el[nameC] == 'undefined') { // No property, custom attribute
                    return el.getAttribute(originalName); // Case sensitive
                  }
                  if (name == 'value' && el.tagName.toLowerCase() == 'input' && el.type.toLowerCase() == 'text') {
                    return el.defaultValue;
                  }
	          return (typeof el[nameC] != 'string' && el[nameC] !== null && el[nameC].toString)?el[nameC].toString():el[nameC];
                }
              }
              return null;
            };
        }
        return function(el, name) {
          var nameLower = name.toLowerCase();
          var alias = attributeAliases[nameLower] || (nameLower.indexOf('-') != -1 && camelize(nameLower)) || nameLower;

          if (typeof el[alias] == 'boolean') {
            if (reUserBoolean.test(nameLower)) {
              return el['default' + nameLower.substring(0, 1).toUpperCase() + nameLower.substring(1)] ? '' : null;
            }
            return el[alias] ? '' : null;
          }

          if (numericAttributesBad && isHostMethod(el, 'hasAttribute')) {
            return hasAttribute(el, name) ? el.getAttribute(name) : null;
          }
          return el.getAttribute(name);
        };
      }
    })();

    API.getAttribute = getAttribute;

    var testAttributePath = '/favicon.ico';

    if (getAttribute) {
      var elA, badReflections, anchorHrefResolves = (function() {
        var el = doc.createElement('a');

        if (el && isHostMethod(el, 'setAttribute')) {
          el.setAttribute('href', testAttributePath);
          return el.href != testAttributePath;
        }
      })();

      if (anchorHrefResolves && isHostMethod(doc, 'createElement')) {
        badReflections = (function() {
          var el, result = {};
          var testReflection = function(tagName, propertyName, el) {
            var attributeName = propertyName.toLowerCase();

            el = el || doc.createElement(tagName);
            if (el && isHostMethod(el, 'setAttribute')) {
              el.setAttribute(attributeName, testAttributePath);
              result[attributeName] = el[propertyName] == testAttributePath;
            }
          };

          testReflection('form', 'action');
          el = doc.createElement('img');
          testReflection('img', 'useMap', el);
          testReflection('img', 'src', el);
          testReflection('img', 'longDesc', el);
          testReflection('link', 'href');
          testReflection('head', 'profile');
          el = doc.createElement('object');
          testReflection('object', 'codeBase', el);
          testReflection('object', 'classid', el);
          testReflection('object', 'data', el);
          testReflection('blockquote', 'cite');
          testReflection('area', 'href');
          return result;
        })();
        elA = doc.createElement('a');
      }

      // For use with HTML DOM's only

      getAttributeProperty = function(el, name) {
        var nameLower = name.toLowerCase();
        var alias = attributeAliases[nameLower] || camelize(nameLower);
        var elHref = elA;

        switch (typeof el[alias]) {
        case 'boolean':
          return reUserBoolean.test(nameLower) ? el['default' + nameLower.substring(0, 1).toUpperCase() + nameLower.substring(1)] : el[alias];
        case 'undefined':

          // Missing expando or event handlers in some browsers (e.g. FF)

          return getAttribute(el, nameLower);
        default:
          if (hasAttribute(el, name)) {
            if (anchorHrefResolves && elA && (reURI.test(nameLower) || nameLower == 'action') && badReflections[nameLower] && !(/^a$/i).test(el.tagName)) {

              var doc = arguments[2] || getElementDocument(el);
              if (doc && doc != global.document && isHostMethod(doc, 'createElement')) {
                elHref = doc.createElement('a');
              }

              elHref.setAttribute('href', getAttribute(el, nameLower));
              return elHref.href;
            }
            return nameLower == 'value' ? getAttribute(el, nameLower) : el[alias];
          }
          return null;
        }
      };

      API.getAttributeProperty = getAttributeProperty;
    }

    // Note: returns element as some attributes (e.g. name, type) will create a new element
    // Ex. el = setAttribute(el, 'name', 'newname');


    if (html) {
      getChildren = (function() {
        if (isHostObjectProperty(html, 'children')) {
          return function(el) {
            var a, c, i, elC;

            if (arguments[1]) {
              return el.children;
            }

            // Filter comment nodes

            a = [];
            c = el.children;
            for (i = c.length; i--;) {
              elC = c[i];
              if ((elC.nodeType == 1 && elC.tagName != '!') || (!elC.nodeType && elC.tagName)) {
                a[a.length] = elC;
              }
            }
            return a.reverse();
          };
        }
        if (isHostMethod(html, 'childNodes')) {
          return function(el) {
            var n, nl = el.childNodes, r = [];
            var i = nl.length;

            while (i--) {
              // Code duplicated for performance
              n = nl[i];
              if ((n.nodeType == 1 && n.tagName != '!') || (!n.nodeType && n.tagName)) {
                r.push(nl[i]);
              }
            }
            return r.reverse();
          };
        }
      })();
    }

    API.getChildren = getChildren;

    reNotEmpty = new RegExp('[^\\t\\n\\r ]');

    API.isEmptyTextNode = function(n) {
      return !reNotEmpty.test(n.data);
    };

    var isXmlParseModeDocument;


    isXmlParseMode = function(docNode) {
      return false;
    };


    isXmlParseModeDocument = isXmlParseMode();

    API.isXmlParseMode = isXmlParseMode;

    createElement = (function() {
      if (isHostMethod(doc, 'createElement')) {
        return (function() {
          if (isXmlParseModeDocument && isHostMethod(doc, 'createElementNS')) {
            return function(tag, docNode) {
              return (docNode || global.document).createElementNS('http://www.w3.org/1999/xhtml', 'html:' + tag);
            };
          }
          return function(tag, docNode) {
            return (docNode || global.document).createElement(tag);
          };
        })();
      }
    })();

    API.createElement = createElement;

    // Text section

    if (String.prototype.trim) {
      trim = function(text) {
        return text.trim();
      };
    } else {
      if (String.fromCharCode(160).replace(/\s/, '').length) {
        trim = function(text) {
          return text.replace(/^[\s\xA0](\s|\xA0)*/, '').replace(/(\s|\xA0)*[\s\xA0]$/, '');
        };
      } else {
        trim = function(text) {
          return text.replace(/^\s\s*/, '').replace(/\s*\s$/, '');
        };
      }
    }

    if (html) {
      getElementText = (function() {
        if (typeof html.innerText == 'string') { return function(el) { return el.innerText; }; }
        if (typeof html.textContent == 'string') { return function(el) { return el.textContent; }; }
        if (isRealObjectProperty(html, 'firstChild')) {
          return function(el) {
            var text = [];
            var c = el.firstChild;
            while (c) {
              if (c.nodeType == 3 || c.nodeType == 4) {
                if (reNotEmpty.test(c.data)) { text[text.length] = c.data; }
              }
              else {
                if (c.nodeType == 1) { text[text.length] = getElementText(c); }
              }
              c = c.nextSibling;
            }
            return text.join('');
          };
        }
      })();

      API.getElementText = getElementText;

      setElementText = (function() {
        var reLT, reGT, reAmp;
        if (typeof html.innerText == 'string') { return function(el, text) { el.innerText = text; }; }
        if (isHostMethod(html, 'removeChild') && isHostMethod(doc, 'createTextNode')) {
          return function(el, text) {
            var docNode = getElementDocument(el);
            while (el.firstChild) { el.removeChild(el.firstChild); }
            el.appendChild(docNode.createTextNode(text));
          };
        }
        if (typeof html.innerHTML == 'string') {
          reLT = new RegExp('<', 'g');
          reGT = new RegExp('>', 'g');
          reAmp = new RegExp('&', 'g');
          return function(el, text) { el.innerHTML = text.replace(reAmp, "&amp;").replace(reLT, "&lt;").replace(reGT, "&gt;"); };
        }
      })();

      API.setElementText = setElementText;
    }
    if (setElementText && getElementText) {
      addElementText = function(el, text) { setElementText(el, getElementText(el) + text); };

      API.addElementText = addElementText;
    }

  }

  var getElementBordersOrigin = function(el) {
    return [el.clientTop || 0, el.clientLeft || 0];
  };

  API.getElementBordersOrigin = getElementBordersOrigin;

  // MS has been known to implement elements as ActiveX objects
  // (e.g. anchors that link to news resources)
  isStyleCapable = !!(html && isRealObjectProperty(html, 'style'));
  if (isStyleCapable) {
    // These flags dictate which style-related functions should be initialized
    canAdjustStyle = {};
    styles = ['display', 'visibility', 'position'];
    iStyle = 3;
    while (iStyle--) {
      canAdjustStyle[styles[iStyle]] = typeof html.style[styles[iStyle]] == 'string';
    }
    API.canAdjustStyle = function(style) { return canAdjustStyle[style]; };
  }

  // Style section
  var floatStyle, getCascadedStyle, getKomputedStyle, getInlineStyle, getObjectStyle, getOverrideStyle, getStyle, getStylePixels, setStyle, setStyles;
  var getPositionedParent, isPositionable, isPresent, isVisible;

  var positionElement;

  var adjustElementSize, sizeElement, sizeElementOuter;

  var positionAndSizeElement, positionAndSizeElementOuter;

  var colorHex, hexByte, hexNibble, hexRGB;
  var rePixels = new RegExp('^(-)?[\\d\\.]*px$', 'i');
  var reOtherUnits = new RegExp('^(-)?[\\d\\.]*(em|pt|cm|in)$', 'i');
  var reColor = new RegExp('color', 'i');
  var reRGB = new RegExp('rgb[a]*\\((\\d*),[\\s]*(\\d*),[\\s]*(\\d*)[),]', 'i');
  var reTransparent = new RegExp('^rgba\\(\\d+,\\s*,\\d+,\\s*\\d,\\s*0\\)$', 'i');
  var colors = { aqua:'00FFFF', green:'008000', navy:'000080', silver:'C0C0C0', black:'000000', gray:'808080', olive:'808000', teal:'008080', blue:'0000FF', lime: '00FF00', purple:'800080', white:'FFFFFF', fuchsia:'FF00FF', maroon:'800000', red:'FF0000', yellow:'FFFF00' };


  var sideNames = ['Top', 'Left', 'Bottom', 'Right'];

  var getElementBorder, getElementBorders;

  var getElementMargin, getElementMargins, getElementMarginsOrigin;

  var addClass, removeClass;

  addClass = function(el, className) {
    var re;
    if (!el.className) {
      el.className = className;
    }
    else {
      re = new RegExp('(^|\\s)' + className + '(\\s|$)');
      if (!re.test(el.className)) { el.className += ' ' + className; }
    }
  };

  API.addClass = addClass;

  removeClass = function(el, className) {
    var re, m;
    if (el.className) {
      if (el.className == className) {
        el.className = '';
      }
      else {
        re = new RegExp('(^|\\s)' + className + '(\\s|$)');
        m = el.className.match(re);
        if (m && m.length == 3) { el.className = el.className.replace(re, (m[1] && m[2])?' ':''); }
      }
    }
  };

  API.removeClass = removeClass;

  if (html) {
    if (isStyleCapable) {

      positionElement = (function() {
        var px = (typeof html.style.top == 'number')?0:'px';
        return function(el, y, x) {
          if (y !== null) { el.style.top = y + px; }
          if (x !== null) { el.style.left = x + px; }
        };
      })();

      API.positionElement = positionElement;

      sizeElement = (function() {
        var px = (typeof html.style.height == 'number')?0:'px';
        return function(el, h, w) {
          if (h !== null && h >= 0) { el.style.height = h + px; } // >= 0 check does not belong in here (not this function's responsibility)
          if (w !== null && w >= 0) { el.style.width = w + px; }
        };
      })();

      API.sizeElement = sizeElement;

      adjustElementSize = function(el, dim) {
         if (el.offsetHeight != dim[0]) {
           dim[0] -= (el.offsetHeight - dim[0]);
           if (dim[0] >= 0) { el.style.height = dim[0] + 'px'; }
         }
         if (el.offsetWidth != dim[1]) {
           dim[1] -= (el.offsetWidth - dim[1]);
           if (dim[1] >= 0) { el.style.width = dim[1] + 'px'; }
         }
         return dim;
      };

      sizeElementOuter = function(el, dim) {
        sizeElement(el, dim);
        adjustElementSize(el, dim);
      };

      API.sizeElementOuter = sizeElementOuter;


      positionAndSizeElement = function(el, r) {
        positionElement(el, r[0], r[1]);
        sizeElement(el, r[2], r[3]);
      };

      positionAndSizeElementOuter = function(el, r) {
        positionAndSizeElement(el, r);
        adjustElementSize(el, [r[2], r[3]]);
      };

      API.positionAndSizeElement = positionAndSizeElement;
      API.positionAndSizeElementOuter = positionAndSizeElementOuter;

      floatStyle = (typeof html.style.cssFloat == 'string')?'cssFloat':'styleFloat';

      getObjectStyle = function(o, style) {
        if (style == 'float') { style = floatStyle; }
        return (o)?o[style] || null:null;
      };

      getCascadedStyle = (function() {
        if (isRealObjectProperty(html, 'currentStyle')) {
          return function(el, style) {
            return getObjectStyle(el.currentStyle, style);
          };
        }
      })();

      API.getCascadedStyle = getCascadedStyle;

      getKomputedStyle = (function() {
        var rePositioned = new RegExp('^(absolute|fixed)$');
        var rePixelConvert = new RegExp('^(height|width|left|top|right|bottom|margin.+|border.+|padding.+)$', 'i');

        if (isRealObjectProperty(doc, 'defaultView') && isHostMethod(doc.defaultView, 'getComputedStyle')) {
          return function(el, style) {
            var docNode = getElementDocument(el);
            var s = docNode.defaultView.getComputedStyle(el, null);
            return getObjectStyle(s, style);
          };
        }
        if (getCascadedStyle) {
          return function(el, style) {
            var floatS, parent, position, styleInline, styleRuntime;
            var value = getCascadedStyle(el, style);
            if (value == 'inherit') {
              parent = getElementParentElement(el);
              if (parent) {
                return getKomputedStyle(parent, style);
              }
            }
            switch(style) {
            case 'float':
              position = getKomputedStyle(el, 'position');
              return (position && rePositioned.test(position))?'none':value;
            case 'display':
              if (value != 'none') {

                // FIXME: Lose this (display bit)

                parent = getElementParentElement(el);
                while (parent) {
                  if (getCascadedStyle(parent, 'display') == 'none') {
                    return 'none';
                  }
                  parent = getElementParentElement(parent);
                }
                position = getKomputedStyle(el, 'position');
                if (position && rePositioned.test(position)) {
                  value = 'block';
                }
                else {
                  floatS = getCascadedStyle(el, 'float');
                  if (floatS && floatS != 'none') {
                    value = 'block';
                  }
                }
              }
              return value;
            }

            if (rePixels.test(value)) { return value; }
            if (reOtherUnits.test(value)) {
              if (rePixelConvert.test(style)) {
                if (parseFloat(value)) {
                  if (isRealObjectProperty(el, 'runtimeStyle')) {
                    styleInline = el.style.left;
                    styleRuntime = el.runtimeStyle.left;
                    el.runtimeStyle.left = el.currentStyle.left;
                    el.style.left = value;
                    value = el.style.pixelLeft;
                    el.style.left = styleInline;
                    el.runtimeStyle.left = styleRuntime;
                    return value + 'px';
                  }
                }
                else {
                  return '0px';
                }
              }
              return null;
            }
            return ((value == 'auto' && style != 'overflow') || value == 'inherit')?null:value;
          };
        }
      })();

      API.getComputedStyle = getKomputedStyle;

      getInlineStyle = function(el, style) {
        var value = getObjectStyle(el.style, style);
        if (typeof value == 'number') { value += 'px'; }
	return value;
      };

      API.getInlineStyle = getInlineStyle;

      getOverrideStyle = (function() {
        if (isRealObjectProperty(doc, 'defaultView') && isHostMethod(doc.defaultView, 'getOverrideStyle')) {
          return function(el, style) {
            var s = getElementDocument(el).defaultView.getOverrideStyle(el, null);
            return getObjectStyle(s, style);
          };
        }
        if (isRealObjectProperty(html, 'runtimeStyle')) {
          return function(el, style) {
            return getObjectStyle(el.runtimeStyle, style);
          };
        }
      })();

      API.getOverrideStyle = getOverrideStyle;


      hexNibble = function(d) {
        return '0123456789ABCDEF'.substring(d, d + 1);
      };

      hexByte = function(d) {
        return hexNibble(Math.floor(d / 16)) + hexNibble(d % 16);
      };

      hexRGB = function(rgb) {
        return [hexByte(rgb[0]), hexByte(rgb[1]), hexByte(rgb[2])].join('');
      };

      colorHex = function(color) {
        var m = reRGB.exec(color);
        if (m) { return ['#', hexByte(parseInt(m[1], 10)), hexByte(parseInt(m[2], 10)), hexByte(parseInt(m[3], 10))].join(''); }
        if (reTransparent.test(color)) { return 'transparent'; }
        return (colors[color])?'#' + colors[color]:null;
      };

      getStyle = (function() {
        var get = (function() {
          if (getKomputedStyle) {
            return function(el, style) {
              var styleO, styleI, styleC;

              if (getOverrideStyle) {
                styleO = getOverrideStyle(el, style);
              }
              if (styleO) { return styleO; }
              styleC = getKomputedStyle(el, style);
              if (styleC) {
                return styleC;
              }
              else {
                styleI = getInlineStyle(el, style);
                styleC = getCascadedStyle && getCascadedStyle(el, style); // Computed value is changed to null for some rules in IE (e.g. font-size:1em)
                if (styleC) {
                  return styleC;
                }
                return ((style == 'display')?'none':styleI) || null;
              }
            };
          }
          return function(el, style) {
            var parent, s = getInlineStyle(el, style);

            // TODO: Lose this (display bit)

            if (style == 'display' && (s != 'none')) {
              parent = getElementParentElement(el);
              while (parent) {
                if (parent.style.display == 'none') {
                  return 'none';
                }
                parent = getElementParentElement(parent);
              }
            }
            return s;
          };
        })();

        return function(el, style) {
          var value = get(el, style);

          return (reColor.test(style))?colorHex(value) || value:value;
        };
      })();

      API.getStyle = getStyle;

      setStyle = function(el, style, value) {
        if (style == 'float') { style = floatStyle; }
        el.style[style] = value;
      };

      API.setStyle = setStyle;

      setStyles = function(el, styles) {
        var s;

        for (s in styles) { if (isOwnProperty(styles, s)) { setStyle(el, s, styles[s]); } }
      };

      API.setStyles = setStyles;

      getStylePixels = function(el, style) {
        var p = getStyle(el, style);
        if (rePixels.test(p)) { return parseFloat(p); }
        if (reOtherUnits.test(p) && !parseFloat(p)) { return 0; } // 0pt
        return null;
      };

      API.getStylePixels = getStylePixels;


      getElementBorder = function(el, border) {
        var b = getStylePixels(el, 'border' + border + 'Width');
        if (b === null) {
          switch(border) {
            case 'Left':
            case 'Right':
              return el.clientLeft || 0;
            case 'Top':
            case 'Bottom':
              return el.clientTop || 0;
          }
        }
        return b;
      };

      API.getElementBorder = getElementBorder;

      getElementBordersOrigin = function(el) {
        return [el.clientTop || getElementBorder(el, 'Top'), el.clientLeft || getElementBorder(el, 'Left')];
      };

      API.getElementBordersOrigin = getElementBordersOrigin;

      getElementBorders = (function() {
        var i;
        return function(el) {
          var borders = {};
          i = sideNames.length;
          while (i--) { borders[sideNames[i]] = getElementBorder(el, sideNames[i]); }
          return borders;
        };
      })();

      API.getElementBorders = getElementBorders;

      getElementMargin = function(el, margin) {
        return getStylePixels(el, 'margin' + margin) || 0;
      };

      API.getElementMargin = getElementMargin;

      getElementMarginsOrigin = function(el, margin) {
        return [getElementMargin(el, 'Top'), getElementMargin(el, 'Left')];
      };

      API.getElementMarginsOrigin = getElementMarginsOrigin;

      getElementMargins = (function() {
        var i;
        return function(el) {
          var margins = {};
          i = sideNames.length;
          while (i--) { margins[sideNames[i]] = getElementMargin(el, sideNames[i]); }
          return margins;
        };
      })();

      API.getElementMargins = getElementMargins;


      getPositionedParent = function(el) {
        var style;
        if (getStyle(el, 'position') != 'fixed' && isRealObjectProperty(el, 'offsetParent')) {
          do {
            el = el.offsetParent;
            if (el) { style = getStyle(el, 'position'); }
          }
          while (el && (!style || style == 'static'));
          return el;
        }
      };

      API.getPositionedParent = getPositionedParent;

      // Determines if an element is logically, rather than empirically visible
      // Display rules of the element or its parents are irrelevant, except that display:none rules obscure even logical visibility in some agents.
      // As with all rules, other than display, it is not possible to get consistent, accurate results for elements that are not part of the layout.
      // For compatibility with agents that cannot compute styles, initially mirror cascaded visibility:hidden rules inline.

      isVisible = function(el) {
        return getStyle(el, 'visibility') != 'hidden';
      };

      API.isVisible = isVisible;

      // For compatibility with agents that cannot compute styles, initially mirror cascaded display:none rules of the element and its parents inline.
      // When the compatibility directions for isVisible and isPresent are followed, empirical visibility can be accurately determined in all agents by isVisible(el) && isPresent(el)

      isPresent = function(el) {
        return getStyle(el, 'display') != 'none';
      };

      API.isPresent = isPresent;

      isPositionable = function(el) {
         var style = getStyle(el, 'position');
         return (style)?(style != 'static'):false;
      };

      API.isPositionable = isPositionable;


    }
  }

  // Events section

  var attachListener, attachDocumentListener, attachWindowListener, detachListener, detachDocumentListener, detachWindowListener;
  var cancelPropagation, cancelDefault, getEventTarget, getEventTargetRelated, getKeyboardKey, getMouseButtons, isEventSupported;
  var normalizedListeners = {}, originalListeners = {}, supportedEvents = {};
  var fnId = 0;

  if (isHostMethod(doc, 'createElement')) {
    isEventSupported = function(eventName, el) {
      eventName = 'on' + eventName;
      var eventKey = eventName + (el && el.tagName || '');

      if (typeof supportedEvents[eventKey] == 'undefined') {
        supportedEvents[eventKey] = true;
        el = el || global.document.createElement('div');
        if (el && isHostMethod(el, 'setAttribute')) {
          if (typeof el[eventName] == 'undefined') {
            el.setAttribute(eventName, 'window.alert(" ");');
            supportedEvents[eventKey] = isHostMethod(el, eventName);
          }
        }
      }
      return supportedEvents[eventKey];
    };
  }

  API.isEventSupported = isEventSupported;
  // These two functions are to clean up leaks created by closures in user code
  // They are attached to the unload event of the window in browsers that do not support addEventListener

  // IE5+ (or any browser that supports attachEvent, but not addEventListener)

  function cleanup() {
    var i = API.attachedListeners.length;
    while (i--) {
      API.attachedListeners[i].el.detachEvent('on' + API.attachedListeners[i].ev, API.attachedListeners[i].fn);
    }
    API.attachedListeners = null;
    //API.eventContexts = null; // Other unload events may fire after this and need their context (attaching unload listeners needs further abstraction)
    global.detachEvent('onunload', cleanup);
  }


  var uniqueTargetHandle = 0;

  function getTargetId(el) {
    if (el.tagName) { // IE document nodes change unique ID's constantly (?)
      return elementUniqueId(el);
    }
    else {
      if (el == global) { return '_apiwin'; } // Don't pollute primary global namespace (window listeners)
      return (el._targetId = el._targetId || ('_api' + uniqueTargetHandle++)); // Use expando for documents
    }
  }

  function addNormalizedListener(el, ev, fnId, fnNormalized, fnOriginal, context) {
    var uid = getTargetId(el);
    if (!normalizedListeners[uid]) { normalizedListeners[uid] = {}; }
    if (!normalizedListeners[uid][ev]) { normalizedListeners[uid][ev] = {}; }
    normalizedListeners[uid][ev][fnId] = fnNormalized;
    originalListeners[fnId] = { fn:fnOriginal, context:context };
  }

  function getNormalizedListener(el, ev, fnId) {
    var uid = getTargetId(el);
    return (normalizedListeners[uid] && normalizedListeners[uid][ev] && normalizedListeners[uid][ev][fnId]);
  }

  function removeNormalizedListener(el, ev, fnId) {
    var uid = getTargetId(el);
    if (normalizedListeners[uid] && normalizedListeners[uid][ev]) {
      normalizedListeners[uid][ev][fnId] = null;
    }
  }

  API.eventContexts = []; // Keeps normalized event closures clean of DOM references
  var eventContextHandle = 0;

  var attachListenerFactory = function(d) {
    return (function() {
      var normalizeFunction = (function() {
        if (Function.prototype.call) {
          return function(fn, handle) {
            return function(e) { return fn.call(API.eventContexts[handle].context, e || API.eventContexts[handle].globalContext.event); };
          };
        }
        else {
          return function(fn, handle) {
            return function(e) { var context = API.eventContexts[handle].context; context.__mylibevent = fn; var r = context.__mylibevent(e || API.eventContexts[handle].globalContext.event); context.__mylibevent = null; return r; };
          };
        }
      })();

      var attach;
      if (isHostMethod(d, 'addEventListener')) {
        return function(d, ev, fn, context) {
          var fnNormalized = (context)?function(e) { return fn.call(context, e); }:fn;
          if (!fn._fnId) {
            fn._fnId = ++fnId;
          }
          addNormalizedListener(d, ev, fn._fnId, fnNormalized, fn, context);
          return d.addEventListener(ev, fnNormalized, false);
        };
      }

      if (isHostMethod(d, 'attachEvent')) {
        attach = function(d, ev, fn, fnNormalized, context) {
          if (!API.attachedListeners) {
            API.attachedListeners = [];
            global.attachEvent('onunload', cleanup);
          }
          addNormalizedListener(d, ev, fn._fnId, fnNormalized, fn, context);
          d.attachEvent('on' + ev, fnNormalized);
          if (!(ev == 'unload' && d == global)) { API.attachedListeners[API.attachedListeners.length] = { el:d, ev:ev, fn:fnNormalized }; }
          d = null;
        };
      }


      if (attach) {
      return function(d, ev, fn, context) {
        var globalContext, docNode = getElementDocument(d);
        if ((docNode || d) == global.document) {
          globalContext = global;
        }
        else {
          if (getDocumentWindow) {
            globalContext = (docNode && getDocumentWindow(docNode)) || getDocumentWindow(d) || d; // element, document or window
          }
        }
        if (globalContext) {
          API.eventContexts[eventContextHandle] = { context:context || d, globalContext:globalContext };
          var fnNormalized = normalizeFunction(fn, eventContextHandle++);
          if (!fn._fnId) {
            fn._fnId = ++fnId;
          }
          if (!getNormalizedListener(d, ev, fn._fnId)) {
            attach(d, ev, fn, fnNormalized, context);
          }
          return true;
        }
        return false;
      };
      }
    })();
  };

  var detachListenerFactory = function(d) {
     var detach = (function() {
       if (isHostMethod(d, 'removeEventListener')) {
         return function(d, ev, fn) {
           d.removeEventListener(ev, fn, false);
         };
       }
       if (isHostMethod(d, 'detachEvent')) {
         return function(d, ev, fn) {
           d.detachEvent('on' + ev, fn);
         };
       }

     })();
     if (detach) {
       return function(d, ev, fn) {
         var fnNormalized;
         if (fn._fnId) {
           fnNormalized = getNormalizedListener(d, ev, fn._fnId);
           if (fnNormalized) {
             removeNormalizedListener(d, ev, fn._fnId);
             detach(d, ev, fnNormalized);
           }
         }
         else {
           detach(d, ev, fn);
         }
       };
     }
  };

  function attachSpecificListenerFactory(obj) {
    var fnAttach = attachListenerFactory(obj);
    return fnAttach && function(ev, fn, objAlt, context) { return fnAttach(objAlt || obj, ev, fn, context); };
  }

  function detachSpecificListenerFactory(obj) {
    var fnDetach = detachListenerFactory(obj);
    return fnDetach && function(ev, fn, objAlt) { return fnDetach(objAlt || obj, ev, fn); };
  }

  if (attachListenerFactory) {

  if (html) {
    attachListener = attachListenerFactory(html);
    if (attachListener) { detachListener = detachListenerFactory(html); }

    API.attachListener = attachListener;
    API.detachListener = detachListener;
  }

  if (doc) {
    attachDocumentListener = attachSpecificListenerFactory(doc);
    if (attachDocumentListener) { detachDocumentListener = detachSpecificListenerFactory(doc); }

    API.attachDocumentListener = attachDocumentListener;
    API.detachDocumentListener = detachDocumentListener;
  }

  attachWindowListener = attachSpecificListenerFactory(this);
  if (attachWindowListener) { detachWindowListener = detachSpecificListenerFactory(this); }

  }

  API.attachWindowListener = attachWindowListener;
  API.detachWindowListener = detachWindowListener;

  purgeListeners = function(el, bChildren, bChildrenOnly) {
    var index, j, original, uid = elementUniqueId(el), nl = normalizedListeners[uid];

    if (!bChildrenOnly) {
      if (nl) {
        for (index in nl) {
          if (isOwnProperty(nl, index)) {
            for (j in nl[index]) {
              if (isOwnProperty(nl[index], j) && nl[index][j]) {
                original = originalListeners[j];
                if (original) {
                  detachListener(el, index, original.fn);
                }
              }
            }
          }
        }
      }
    }
    if (bChildren && el.childNodes) {
      index = el.childNodes.length;
      while (index--) {
        if (el.childNodes[index].nodeType == 1) { purgeListeners(el.childNodes[index], true); }
      }
    }
  };

  API.purgeListeners = purgeListeners;

  var callInContext = (function() {
    if (Function.prototype.call) {
      return function(fn, context, arg1, arg2) {
        return fn.call(context, arg1, arg2);
      };
    }
    return function(fn, context, arg1, arg2) {
      context.__mylibevent = fn;
      var r = context.__mylibevent(arg1, arg2);
      context.__mylibevent = null;
      return r;
    };
  })();

  var assistedEvents = {}, assistedEventListeners = {};

  function hasAssistedEventListeners(el, ev) {
    var uid = elementUniqueId(el);
    return !!(assistedEventListeners[uid] && assistedEventListeners[uid][ev]);
  }

  function addAssistedEventListeners(el, ev, listeners) {
    var uid = elementUniqueId(el);
    assistedEventListeners[uid] = assistedEventListeners[uid] || {};
    if (!assistedEventListeners[uid][ev]) {
      assistedEventListeners[uid][ev] = listeners;
      return true;
    }
    return false;
  }

  function removeAssistedEventListeners(el, ev) {
    var listeners, uid = elementUniqueId(el);
    if (assistedEventListeners[uid] && assistedEventListeners[uid][ev]) {
      listeners = assistedEventListeners[uid][ev];
      assistedEventListeners[uid][ev] = null;
    }
    return listeners;
  }

  function detachAssistedEventListeners(el, ev) {
    var index, listeners = removeAssistedEventListeners(el, ev);
    if (listeners) {
      for (index in listeners) {
        if (isOwnProperty(listeners, index)) {
          detachListener(el, index, listeners[index]);
        }
      }
    }
  }


  var attachMousewheelListener, detachMousewheelListener, getMousewheelDelta, mousewheelListenerFactory;

  // Event normalization
  if (attachListener) {
    getKeyboardKey = function(e) {
      return (e.type == 'keypress')?e.charCode || e.keyCode || e.which:e.which || e.keyCode;
    };

    API.getKeyboardKey = getKeyboardKey;

    cancelPropagation = function(e) {
      if (e.stopPropagation) { e.stopPropagation(); } else { e.cancelBubble = true; }
    };

    API.cancelPropagation = cancelPropagation;

    cancelDefault = function(e) {
      if (e.preventDefault) { e.preventDefault(); }
      if (global.event) { global.event.returnValue = false; }
      return false;
    };

    API.cancelDefault = cancelDefault;

    getMouseButtons = function(e) {
      var b = {};
      if (typeof e.which != 'undefined') {
        b.left = (e.which == 1);
        b.middle = (e.which == 2);
        b.right = (e.which == 3);
      }
      else {
        b.left = (e.button & 1);
        b.middle = (e.button & 4);
        b.right = (e.button & 2);
      }
      return b;
    };

    API.getMouseButtons = getMouseButtons;

    getEventTarget = function(e) {
      return (e.target)?((e.target.nodeType == 3)?e.target.parentNode:e.target):e.srcElement;
    };

    API.getEventTarget = getEventTarget;

    getEventTargetRelated = function(e) {
      if (e.relatedTarget) { return (e.relatedTarget.nodeType == 3)?e.relatedTarget.parentNode:e.relatedTarget; }
      if (e.srcElement) {
        if (e.srcElement == e.fromElement) { return e.toElement; }
        if (e.srcElement == e.toElement) { return e.fromElement; }
      }
      return null;
    };

    API.getEventTargetRelated = getEventTargetRelated;

    // Assisted events


    getMousewheelDelta = function(e) {
      return (e.detail)?-(e.detail) / 3:e.wheelDelta / 120;
    };

    API.getMousewheelDelta = getMousewheelDelta;

    mousewheelListenerFactory = function(fn) {
      return function(e) {
        callInContext(fn, this, e, getMousewheelDelta(e));
        return cancelDefault(e);
      };
    };

    //if (!isEventSupported || isEventSupported('DOMMouseScroll') || isEventSupported('mousewheel')) {
      attachMousewheelListener = (function() {
        function attach(el, fn, context) {
          if (!hasAssistedEventListeners(el, 'mousewheel')) {
            attachListener(el, 'mousewheel', fn, context);
            attachListener(el, 'DOMMouseScroll', fn, context);
            addAssistedEventListeners(el, 'mousewheel', { mousewheel:fn, DOMMouseScroll:fn });
          }
        }
        return function(el, fn, context) {
          attach(el, mousewheelListenerFactory(fn), context);
        };
      })();

      detachMousewheelListener = function(el) {
        detachAssistedEventListeners(el, 'mousewheel');
      };

      assistedEvents.Mousewheel = { attach:attachMousewheelListener, detach:detachMousewheelListener };
    //}
    API.attachMousewheelListener = attachMousewheelListener;
    API.detachMousewheelListener = detachMousewheelListener;

  }

  var getBodyElement, getContainerElement;

  var defaultDisplay, presentElement, toggleElementPresence;

  var getElementPositionStyle;

  var getElementSizeStyle;

  var getScrollPosition, getScrollPositionMax, getElementScrollPosition, getElementScrollPositionMax, setScrollPosition, setElementScrollPosition;

  var getMousePosition;

  var ensureSizable;

  var contained = function(pos1, dim1, pos2, dim2) {
    return ((pos1[0] >= pos2[0]) && (pos1[0] <= pos2[0] + dim2[0]) && (pos1[1] >= pos2[1]) && (pos1[1] <= pos2[1] + dim2[1]) && (pos1[0] + dim1[0] <= pos2[0] + dim2[0]) && (pos1[1] + dim1[1] <= pos2[1] + dim2[1]));
  };
  var overlaps = function(pos1, dim1, pos2, dim2) {
    return (((pos1[1] >= pos2[1]) && (pos1[1] <= pos2[1] + dim2[1])) || ((pos1[1] < pos2[1]) && (pos1[1] + dim1[1] > pos2[1]))) && (((pos1[0] >= pos2[0]) && (pos1[0] <= pos2[0] + dim2[0])) || ((pos1[0] < pos2[0]) && (pos1[0] + dim1[0] > pos2[0])));
  };

  var constrainPosition = function(c, co, dim, constraint) {
    if (co[0] < constraint[0]) { c[0] += (constraint[0] - co[0]); }
    if (co[1] < constraint[1]) { c[1] += (constraint[1] - co[1]); }
    if (co[0] + dim[0] > constraint[0] + constraint[2]) { c[0] += (constraint[0] + constraint[2] - (co[0] + dim[0])); }
    if (co[1] + dim[1] > constraint[1] + constraint[3]) { c[1] += (constraint[1] + constraint[3] - (co[1] + dim[1])); }
  };

  var constrainSize = function(c, co, pos, constraint) {
    if (co[0] + pos[0] > constraint[0] + constraint[2]) { c[0] += (constraint[0] + constraint[2] - (co[0] + pos[0])); }
    if (co[1] + pos[1] > constraint[1] + constraint[3]) { c[1] += (constraint[1] + constraint[3] - (co[1] + pos[1])); }
  };

  var absoluteElement, ensurePositionable, getElementPositionedChildPosition, relativeElement;

  var overlayElement;

  var getElementPosition;

  var effects, spring;

  var attachDrag, detachDrag, initiateDrag, attachedDrag = {};

  if (attachDocumentReadyListener) {
    attachDocumentReadyListener(function() {
      var body, containerElement;

      getBodyElement = function(docNode) {
        docNode = docNode || global.document;
        if (isRealObjectProperty(docNode, 'body')) { return docNode.body; }
        if (typeof getEBTN == 'function') { return getEBTN('body', docNode)[0] || null; }
        return null;
      };

      API.getBodyElement = getBodyElement;

      body = getBodyElement();

      // Returns documentElement or body as best deemed appropriate
      // Result is ambiguous in all but modern browsers, so don't assume too much from it.
      getContainerElement = function(docNode) {
        docNode = docNode || global.document;
        return (docNode.documentElement && (!docNode.compatMode || docNode.compatMode.indexOf('CSS') != -1))?docNode.documentElement:getBodyElement(docNode);
      };

      API.getContainerElement = getContainerElement;

      containerElement = getContainerElement();

      var computedSizeBad;

      var computedPositionBad;

      var div, div2;

      // Scroll section

      function normalizeScroll(t, l, p) {
        if (t) {
          if (t > p[0]) { t = p[0]; }
          if (t < 0) { t = 0; }
        }
        if (l) {
          if (l > p[1]) { l = p[1]; }
          if (l < 0) { l = 0; }
        }
        return [t, l];
      }

      function findWindow(docNode) {
        if (!docNode || docNode == global.document) {
          return global;
        }
        return (getDocumentWindow)?getDocumentWindow(docNode):null;
      }

      getScrollPosition = (function() {
        if (typeof global.pageXOffset == 'number') {
          return function(docNode) {
            var win = findWindow(docNode);
            return (win)?[win.pageYOffset, win.pageXOffset]:null;
          };
        }

        function findScroll(o) {
          return (o && (o.scrollTop || o.scrollLeft)) && (getScrollPosition = API.getScrollPosition = function() { return [o.scrollTop, o.scrollLeft]; })();
        }

        function findScrollChanged(o, docNode) {
          return (o.scrollTop != docNode._scrollPositionSetLast[0] || o.scrollLeft != docNode._scrollPositionSetLast[1]) && (getScrollPosition = API.getScrollPosition = function() { return [o.scrollTop, o.scrollLeft]; })();
        }

        if (global.document.expando || typeof global.document.expando == 'undefined') {
          return function(docNode) {
            var b = getBodyElement(docNode);
            var c = getContainerElement(docNode);

            docNode = docNode || global.document;
            if (!docNode._scrollPositionSetLast) {
              docNode._scrollPositionSetLast = [];
            }
            return ((typeof docNode._scrollPositionSetLast[0] == 'number' && (findScrollChanged(c, docNode) || findScrollChanged(b, docNode))) || findScroll(docNode.documentElement) || findScroll(b)) || [0, 0];
          };
        }
      })();

      API.getScrollPosition = getScrollPosition;

      setScrollPosition = (function() {
        var pos, sp;

        var scroll = (function() {
          if (isHostMethod(global, 'scrollTo')) {
            return function(t, l, docNode) {
              var win = arguments[3] || findWindow(docNode); // Fourth argument is for internal optimization (scrolling effects)

              if (win) { win.scrollTo(pos[1], pos[0]); }
            };
          }
          // Ambiguous branch for agents that do not support window.scrollTo
          if (global.document.expando || typeof global.document.expando == 'undefined') {
            if ((containerElement && typeof containerElement.scrollTop == 'number') || (body && typeof body.scrollTop == 'number')) {
              return function(t, l, docNode) {
                var b = getBodyElement(docNode);
                var c = getContainerElement(docNode);

                docNode = docNode || global.document;
                if (!docNode._scrollPositionSetLast) {
                  docNode._scrollPositionSetLast = [];
                }
                if (b) { // b implies c
                  c.scrollTop = b.scrollTop = docNode._scrollPositionSetLast[0] = t;
                  c.scrollLeft = b.scrollLeft = docNode._scrollPositionSetLast[1] = l;
                }
              };
            }
          }
        })();
        if (scroll) {
          return function(t, l, docNode, isNormalized) {
            pos = (!getScrollPositionMax || isNormalized || (!t && !l))?[t, l]:normalizeScroll(t, l, getScrollPositionMax(docNode));
            if (pos[0] === null || pos[1] === null) {
              sp = getScrollPosition(docNode);
              if (pos[0] === null) { pos[0] = sp[0]; }
              if (pos[1] === null) { pos[1] = sp[1]; }
            }
            scroll(pos[0], pos[1]);
          };
        }
      })();

      API.setScrollPosition = setScrollPosition;

      getScrollPositionMax = (function() {
        if (typeof global.scrollMaxX != 'undefined') {
          return function(docNode) {
            var win = findWindow(docNode);
            return (win)?[win.scrollMaxY, win.scrollMaxX]:null;
          };
        }
      })();

      API.getScrollPositionMax = getScrollPositionMax;

      getElementScrollPosition = function(el) {
        return [el.scrollTop || 0, el.scrollLeft || 0];
      };

      API.getElementScrollPosition = getElementScrollPosition;

      setElementScrollPosition = function(el, t, l, isNormalized) {
        var pos = (isNormalized || (!t && !l))?[t, l]:normalizeScroll(t, l, getElementScrollPositionMax(el));
        if (pos[0] !== null) { el.scrollTop = pos[0]; }
        if (pos[1] !== null) { el.scrollLeft = pos[1]; }
      };

      API.setElementScrollPosition = setElementScrollPosition;

      getElementScrollPositionMax = function(el) {
        var d = getElementSize(el);
        return [d[4] - d[2], d[5] - d[3]];
      };


      var htmlOffsetsOrigin, html = getHtmlElement();
      var viewportToHtmlOrigin, htmlToViewportOrigin;

      if (html && isHostMethod(global.document, 'getBoxObjectFor') && typeof getElementBordersOrigin == 'function' && typeof getElementMarginsOrigin == 'function') {
        (function() {
          var m = getElementMarginsOrigin(html);
          var b = getElementBordersOrigin(html);

          var rect = global.document.getBoxObjectFor(html);

          if (!rect) { return; } // Embedded Gecko browsers

          if ((m[0] || m[1] || b[0] || b[1]) && (rect.y == m[0] + b[0] && rect.x == m[1] + b[1])) { // Gecko
            htmlOffsetsOrigin = function(docNode) {
              var x, y;
              var html = getHtmlElement(docNode);
              var borders = getElementBordersOrigin(html);
              var margins = getElementMarginsOrigin(html);
              y = borders[0] + margins[0];
              x = borders[1] + margins[1];
              return [y, x];
            };
          }
          else { // Mozilla
            if (rect.x || rect.y) {
              htmlOffsetsOrigin = function(docNode) {
                docNode = docNode || global.document;
                var html = getHtmlElement(docNode);
                var rect = docNode.getBoxObjectFor(html);
                return [rect.x, rect.y];
              };
            }
          }

          if (htmlOffsetsOrigin) {
            viewportToHtmlOrigin = function(pos, docNode) {
              var o = htmlOffsetsOrigin(docNode);
              o[0] += pos[0];
              o[1] += pos[1];
              return o;
            };

            htmlToViewportOrigin = function(pos, docNode) {
              var o = htmlOffsetsOrigin(docNode);
              o[0] = pos[0] - o[0];
              o[1] = pos[1] - o[1];
              return o;
            };

            API.viewportToHtmlOrigin = viewportToHtmlOrigin;
            API.htmlToViewportOrigin = htmlToViewportOrigin;
          }
        })();
      }

      if (setScrollPosition) {
        API.setScrollPositionTop = function(docNode, options, fnDone) { setScrollPosition(0, null, docNode, null, options, fnDone); };
        API.setScrollPositionLeft = function(docNode, options, fnDone) { setScrollPosition(null, 0, docNode, null, options, fnDone); };
        if (getScrollPositionMax) {
          API.setScrollPositionBottom = function(docNode, options, fnDone) { setScrollPosition(getScrollPositionMax(docNode)[0], null, docNode, true, options, fnDone); };
          API.setScrollPositionRight = function(docNode, options, fnDone) { setScrollPosition(null, getScrollPositionMax(docNode)[1], docNode, true, options, fnDone); };
        }
	API.setScrollPositionRelative = function(t, l, docNode, options, fnDone) {
          var sp = getScrollPosition(docNode);
          if (t !== null) { t += sp[0]; }
          if (l !== null) { l += sp[1]; }
          setScrollPosition(t, l, docNode, false, options, fnDone);
        };
      }

      API.setElementScrollPositionTop = function(el, options, fnDone) {
        setElementScrollPosition(el, 0, null, null, options, fnDone);
      };

      API.setElementScrollPositionLeft = function(el, options, fnDone) {
        setElementScrollPosition(el, null, 0, null, options, fnDone);
      };

      API.setElementScrollPositionBottom = function(el, options, fnDone) {
        setElementScrollPosition(el, getElementScrollPositionMax(el)[0], null, true, options, fnDone);
      };

      API.setElementScrollPositionRight = function(el, options, fnDone) {
        setElementScrollPosition(el, null, getElementScrollPositionMax(el)[1], true, options, fnDone);
      };

      API.setElementScrollPositionRelative = function(el, t, l, options, fnDone) {
        var sp = getElementScrollPosition(el);
        if (t !== null) { t += sp[0]; }
        if (l !== null) { l += sp[1]; }
        setElementScrollPosition(el, t, l, false, options, fnDone);
      };

      // Offset section

      getElementPosition = (function() {
        var b;
        var scrollerOffsetSubtractsBorder, offsetAbsoluteExcludesBodyBorder, nestedElementsOffsetFromBody, nestedInlineOffsetIncludesScroll, offsetIncludesBorder, offsetIncludesBodyBorder;

        if (typeof isStyleCapable == 'boolean' && isStyleCapable && createElement && body && body.appendChild && body.removeChild) {
          // Feature tests for browser quirks
          var divOuter = createElement('div');
          var divInner = createElement('div');

          if (divInner && divOuter) {
            // Windows Safari indicates false positive for this test
            scrollerOffsetSubtractsBorder = (function() {
              setStyles(divOuter, {position:'absolute', visibility:'hidden', left:'0', top:'0', padding:'0', border:'solid 1px black', 'overflow':'auto'});
              setStyles(divInner, {position:'static', left:'0', top:'0'});
              divOuter.appendChild(divInner);
              body.appendChild(divOuter);
              b = divInner.offsetLeft == -1;
              body.removeChild(divOuter);
              divOuter.removeChild(divInner);
              return b;
            })();

            // Windows Safari oddity
            offsetAbsoluteExcludesBodyBorder = (function() {
              var bbl = getElementBordersOrigin(body)[1];
              if (bbl) {
                body.appendChild(divOuter);
                b = divOuter.offsetLeft == -bbl;
                body.removeChild(divOuter);
                return b;
              }
            })();

            // All but IE
            nestedElementsOffsetFromBody = (function() {
              setStyles(divOuter, {position:'static', height:'0', width:'0', border:'none'});
              setStyles(divInner, {height:'0', width:'0'});
              divOuter.appendChild(divInner);
              body.appendChild(divOuter);
              b = divInner.offsetParent === body;
              body.removeChild(divOuter);
              divOuter.removeChild(divInner);
              return b;
            })();

            // Opera oddity
            if (isHostMethod(global.document, 'createTextNode')) {
              nestedInlineOffsetIncludesScroll = (function() {
                var span = createElement('span');
                var tn = global.document.createTextNode('Initializing...');
                span.appendChild(tn);
                divInner.appendChild(span);
                setStyles(divOuter, {overflow:'auto'});
                divOuter.appendChild(divInner);
                body.appendChild(divOuter);
                var o = span.offsetTop;
                divOuter.scrollTop = 1;
                b = o != span.offsetTop;
                body.removeChild(divOuter);
                return b;
              })();
            }

            // Opera oddity
            offsetIncludesBorder = (function() {
              setStyles(divOuter, {position:'absolute', visibility:'hidden', left:'0', top:'0', padding:'0', border:'solid 1px'});
              setStyles(divInner, {position:'absolute', left:'0', top:'0', margin:'0'});
              divOuter.appendChild(divInner);
              body.appendChild(divOuter);
              b = divInner.offsetLeft == 1;
              body.removeChild(divOuter);
              divOuter.removeChild(divInner);
              return b;
            })();

            var bodyBorderWidth = getStylePixels(body, 'borderLeftWidth');

            if (bodyBorderWidth) {
              offsetIncludesBodyBorder = (function() {
                divOuter = API.createElement('div');
                setStyles(divOuter, {position:'static', visibility:'hidden', padding:'0', border:'0'});
                if (body.firstChild) {
                  body.insertBefore(divOuter, body.firstChild);
                } else {
                  body.appendChild(divOuter);
                }
                b = divOuter.offsetLeft == bodyBorderWidth;
                body.removeChild(divOuter);
                return b;
              })();
            }

            divInner = divOuter = null;
          }
        }

        function scrollFix(el, body) {
          var scrollerPos, scrollerOverflow, borders, p = [0, 0, 0, 0];
          var pos = getStyle(el, 'position');

          if (pos != 'fixed') { // TODO: Check before calling
            while (el.parentNode && el.parentNode !== body) {
              el = el.parentNode;
              scrollerPos = getStyle(el, 'position') || 'static';
              scrollerOverflow = getStyle(el, 'overflow');
              if (!((scrollerPos == 'static' && pos == 'absolute') || pos == 'fixed')) {
                if ((el.scrollTop || el.scrollLeft) && scrollerOverflow != 'visible') {
                  p[0] -= (el.scrollTop || 0);
                  p[1] -= (el.scrollLeft || 0);
                  if (scrollerOffsetSubtractsBorder) {
                    borders = getElementBordersOrigin(el);
                    p[2] += borders[0];
                    p[3] += borders[1];
                  }
                }
              }
            }
          }
          return p;
        }

        function positionOffset(el, elContainer, noScrollFix) {
          var x = 0, y = 0, body, borders, pos;
          var scrollPos, sf = [0, 0, 0, 0];
          var elOriginal = el;
          var docNode = getElementDocument(el);

          if (docNode) {
            body = getBodyElement(docNode);
          }

          // Fixed position in Opera has no offsetParent
          if (!el.offsetParent && typeof getElementPositionStyle == 'function') {
            return getElementPositionStyle(el, null);
          }

          if (el.offsetParent === body) {
            if (elContainer && nestedElementsOffsetFromBody) {
              var po = positionOffset(elContainer);
              y = -po[0];
              x = -po[1];
            }
          }
          if (elContainer && (offsetIncludesBorder || (nestedElementsOffsetFromBody && el.offsetParent == body))) {
            borders = getElementBordersOrigin(elContainer);
            y -= borders[0];
            x -= borders[1];
          }
          if (typeof getStyle == 'function') {
            var d = getStyle(el, 'display');
            sf = scrollFix(el, body);
            if (noScrollFix) {
              if (nestedInlineOffsetIncludesScroll && d == 'inline') {
                y -= sf[0];
                x -= sf[1];
              }
            }
            else {
              if ((!nestedInlineOffsetIncludesScroll || (!d || d != 'inline'))) {
                y += sf[0];
                x += sf[1];
              }
            }
            if (scrollerOffsetSubtractsBorder) {
              y += sf[2];
              x += sf[3];
            }
          }

          // TODO: Convert internal typeof checks to resolved references (API.*) as can allow global identifier collisions in partial builds

          if (typeof getStyle == 'function' && docNode && typeof getScrollPosition == 'function') {
            pos = getStyle(el, 'position');

            if (pos == 'fixed') {
              scrollPos = getScrollPosition(docNode);
              x += scrollPos[1];
              y += scrollPos[0];
            }
          }

          do {
            if (el !== body || (el.offsetLeft > 0 && el.offsetTop > 0)) {
              if (el.offsetLeft) { x += el.offsetLeft; }
              if (el.offsetTop) { y += el.offsetTop; }
            }

            if (!offsetIncludesBorder && el !== elOriginal && (!offsetIncludesBodyBorder || el !== body)) {
              b = getElementBordersOrigin(el);
              y += b[0];
              x += b[1];
            }

            if ((pos == 'absolute' || pos == 'fixed') && el.offsetParent === body) {
              if (offsetAbsoluteExcludesBodyBorder) {
                b = getElementBordersOrigin(body);
                y += b[0];
                x += b[1];
              }
              el = null;
            } else {
              el = el.offsetParent;
            }
          }
          while (el && el !== elContainer);
          return [y, x];
        }

        if (isHostMethod(global.document, 'getBoxObjectFor')) {
          return function(el, elContainer, noScrollFix) {
            var pos, borders, parentNode, sf, sp, stylePos;
            var posContainer = (elContainer)?getElementPosition(elContainer):[0, 0];
            var docNode = getElementDocument(el);
            var body = getBodyElement(docNode);
            var rect = docNode.getBoxObjectFor(el);

            if (!rect) { return positionOffset(el, elContainer, noScrollFix); } // Embedded Gecko browsers

            pos = [rect.y, rect.x];
            if (typeof getStyle == 'function') {
              parentNode = el;
              while (parentNode && parentNode.nodeType == 1 && stylePos != 'fixed') {
                stylePos = getStyle(parentNode, 'position');
                parentNode = parentNode.parentNode;
              }
              if (stylePos == 'fixed') {
                sp = (typeof getScrollPosition == 'function')?getScrollPosition(docNode):[0, 0];
                pos[0] += sp[0];
                pos[1] += sp[1];
                if (htmlToViewportOrigin) { pos = htmlToViewportOrigin(pos, docNode); }
              }
              else {
                if (!noScrollFix) {
                  sf = scrollFix(el, body);
                  pos[0] += sf[0] + sf[2];
                  pos[1] += sf[1] + sf[3];
                }
              }
            }
            borders = getElementBordersOrigin(el);
            return [pos[0] - borders[0] - posContainer[0], pos[1] - borders[1] - posContainer[1]];
          };
        }
        if (body && isHostMethod(body, 'getBoundingClientRect')) {
          return function(el, elContainer, noScrollFix) {
            if (elContainer) {
              return positionOffset(el, elContainer, noScrollFix);
            }
            else {
              var x, y;
              var rect = el.getBoundingClientRect();
              var docNode = getElementDocument(el);
              var body = getBodyElement(docNode);
              var ce = getHtmlElement(docNode);
              var sp = [0, 0];

              y = rect.top;
              x = rect.left;

              if (ce) {
                if (body && ce != body && ce.clientWidth === 0 && typeof body.clientTop == 'number') {
                  ce = body;
                }
                if (ce.clientTop) { y -= ce.clientTop; }
                if (ce.clientLeft) { x -= ce.clientLeft; }
                if (ce.scrollTop || ce.scrollLeft) { sp = [ce.scrollTop, ce.scrollLeft]; }
              }
              if (typeof getScrollPosition == 'function') {
                sp = getScrollPosition(docNode);
              }
              y += sp[0];
              x += sp[1];
              return [y, x];
            }
          };
        }
        return positionOffset;
      })();

      API.getElementPosition = getElementPosition;

      if (setScrollPosition) {
        API.setScrollPositionToElement = function(el, offset, options, fnDone) {
          var docNode, p;
          if (isHostMethod(el, 'scrollIntoView') && !offset && !options) {
            el.scrollIntoView();
          }
          else {
            docNode = getElementDocument(el);
            p = getElementPosition(el);
            if (viewportToHtmlOrigin) { p = viewportToHtmlOrigin(p, docNode); }
            offset = offset || [];
            setScrollPosition(p[0] - (offset[0] || 0), p[1] - (offset[1] || 0), docNode, false, options, fnDone);
          }
        };

        API.setScrollPositionCenterElement = function(el, options, fnDone) {
          var vs = getViewportSize(getElementDocument(el));
          var es = getElementSize(el);
          API.setScrollPositionToElement(el, [Math.round((vs[0] - es[0]) / 2), Math.round((vs[1] - es[1]) / 2)], options, fnDone);
        };
      }

      API.setElementScrollPositionToElement = function(el, elTo, offset, options, fnDone) {
        var p;
        offset = offset || [];
        p = (getPositionedParent(elTo) === el)?getElementPositionedChildPosition(elTo, el):getElementPosition(elTo, el);
        setElementScrollPosition(el, p[0] - (offset[0] || 0), p[1] - (offset[1] || 0), false, options, fnDone);
      };

      API.setElementScrollPositionCenterElement = function(el, elTo, options, fnDone) {
        var h, w, d;
        d = getElementSize(el);
        h = d[2];
        w = d[3];
        d = getElementSize(elTo);
        setElementScrollPosition(el, elTo, [Math.round((h - d[0]) / 2), Math.round((w - d[1]) / 2)], false, options, fnDone);
      };

      getMousePosition = (function() {
        var sp, ce, body;

        return function(e) {
          if (typeof e.pageX == 'number') {
            getMousePosition = API.getMousePosition = function(e) { return [e.pageY, e.pageX]; };
            return getMousePosition(e);
          }
          if (typeof e.clientX == 'number' && typeof getScrollPosition == 'function') {
            getMousePosition = API.getMousePosition = function(e, docNode) {
              docNode = docNode || getElementDocument(getEventTarget(e));
              if (docNode) {
                body = getBodyElement(docNode);
                ce = getContainerElement(docNode);
                if (body && ce != body && ce.clientWidth === 0 && typeof body.scrollWidth == 'number') {
                  ce = body; // TODO: call getScrollElement here instead
                }
                sp = getScrollPosition(docNode);
                return [e.clientY + sp[0] - (ce.clientTop || 0), e.clientX + sp[1] - (ce.clientLeft || 0)];
              }
            };
            return getMousePosition(e);
          }
        };
      })();

      API.getMousePosition = getMousePosition;

      if (attachListener) {
      attachDrag = (function() {
        var i, c, m;
        var elDrag, elDragHandle, docNode, win, mode, ondrag, ondraginit, ondragterminate, ondragstart, ondragover, ondragout, ondrop, ghost, speed, accelerate, revert, axes, constrain, constraint, keyboardOnly, callbackContext;
        var targets, targetPositions, targetDimensions, targetsOver, targetObstacles, obstaclesFatal, collision;
        var mouse, dim, pos, dimO, posO, scrollPos, oldStyle = {};
        var initialized;
        var oldMouseDown, oldKeyDown, oldKeyUp;
        var oldSpeed;

        function callback(c, co) {
          var targetsOut;
          if (targets) {
            if (mode == 'move') {
              targetsOut = [];
              i = targetsOver.length;

              while (i--) {
                if (!overlaps(co, dimO, targetPositions[targetsOver[i]], targetDimensions[targetsOver[i]])) {
                  targetsOut[targetsOut.length] = i;
                }
              }
              if (targetsOut.length) {
                if (ondragout) { callInContext(ondragout, callbackContext, targetsOut); }
              }
              targetsOver = [];
              i = targets.length;
              while (i--) {
                if (overlaps(co, dimO, targetPositions[i], targetDimensions[i])) {
                  targetsOver[targetsOver.length] = i;
                }
              }
              if (targetsOver.length) {
                if (ondragover) { callInContext(ondragover, callbackContext, c, targetsOver, m); }
                if (targetObstacles) { if (obstaclesFatal) { collision = true; } return false; }
              }
            }
          }
          if (constrain) {
            switch(mode) {
            case 'move':
              if (!contained(co, dimO, [constraint[0], constraint[1]], [constraint[2], constraint[3]])) {
                constrainPosition(c, co, dimO, constraint);
              }
              break;
            case 'size':
              if (!contained(posO, co, [constraint[0], constraint[1]], [constraint[2], constraint[3]])) {
                constrainSize(c, co, posO, constraint);
              }
            }
          }
          return !ondrag || !callInContext(ondrag, callbackContext, c, co, m);
        }

        function initializeMove() {
          initialized = true;
          if (ghost && typeof setOpacity == 'function') { setOpacity(elDrag, ghost); }

          if (!isPositionable(elDrag)) {
            absoluteElement(elDrag);
            pos = getElementPositionStyle(elDrag);
          }

          if (targets) {
            targetsOver = [];
            targetPositions = [];
            targetDimensions = [];
            i = targets.length;
            while (i--) {
              if (isRealObjectProperty(targets[i], 'offsetParent')) { // Must be part of document
                targetPositions[i] = getElementPosition(targets[i]);
                targetDimensions[i] = getElementSize(targets[i]);
              }
            }
          }
        }

        function initializeSize() {
          ensureSizable(elDrag);
          initialized = true;
        }

        function size(e) {
          var co;
          if (!initialized) { if (ondragstart) { callInContext(ondragstart, callbackContext); } initializeSize(); }
          m = getMousePosition(e, docNode);
          if (m) {
            c = [(axes == 'horizontal')?null:(dim[0] + (m[0] - mouse[0])), (axes == 'vertical')?null:(dim[1] + (m[1] - mouse[1]))];
            if (constrain) { co = [(axes == 'horizontal')?null:(dimO[0] + (m[0] - mouse[0])), (axes == 'vertical')?null:(dimO[1] + (m[1] - mouse[1]))]; }
            if (callback(c, co)) {
              if (c[0] < 0) { c[0] = 0; }
              if (c[1] < 0) { c[1] = 0; }
              sizeElement(elDrag, c[0], c[1]);
            }
          }
          return cancelDefault(e);
        }

        function scroll(e) {
          if (!initialized) {
            if (ondragstart) { callInContext(ondragstart, callbackContext); }
            initialized = true;
          }
          m = getMousePosition(e, docNode);
          if (m) {
            c = [(axes == 'horizonal')?null:(scrollPos[0] + (m[0] - mouse[0])), (axes == 'vertical')?null:(scrollPos[1] + (m[1] - mouse[1]))];
            if (callback(c)) {
              setElementScrollPosition(elDrag, c[0], c[1]);
            }
          }
          return cancelDefault(e);
        }

        var finish;

        function drag(e) {
          var co;
          if (!initialized) { if (ondragstart) { callInContext(ondragstart, callbackContext); } initializeMove(); }
          m = getMousePosition(e, docNode);
          if (m) {
            c = [(axes == 'horizontal')?null:(pos[0] + (m[0] - mouse[0])), (axes == 'vertical')?null:(pos[1] + (m[1] - mouse[1]))];
            if (targets || constrain) { co = [(axes == 'horizontal')?null:(posO[0] + (m[0] - mouse[0])), (axes == 'vertical')?null:(posO[1] + (m[1] - mouse[1]))]; }
            if (callback(c, co)) {
              positionElement(elDrag, c[0], c[1]);
            }
            else {
              if (collision) { finish(); }
            }
          }
          return cancelDefault(e);
        }

        finish = function() {
          if (ondragterminate) { callInContext(ondragterminate, callbackContext); }
          if (!keyboardOnly) {
            detachListener(docNode, 'mousemove', (mode == 'size')?size:(mode == 'scroll')?scroll:drag);
            detachListener(docNode, 'mouseup', finish);
          }
          docNode.onmousedown = oldMouseDown;
          docNode.onkeydown = oldKeyDown;
          docNode.onkeyup = oldKeyUp;
          if (initialized) {
            if (!ondrop || !callInContext(ondrop, callbackContext, targetsOver)) {
              if (revert) {
                setStyles(elDrag, { position:oldStyle.position, left:oldStyle.left, top:oldStyle.top, width:oldStyle.width, height:oldStyle.height });
                if (mode == 'scroll') { setElementScrollPosition(elDrag, scrollPos[0], scrollPos[1]); }
              }
            }
            if (mode == 'move' && ghost && typeof setOpacity == 'function') { setOpacity(elDrag, 1); }
          }
          docNode = null;
          win = null;
          elDrag = null;
          elDragHandle = null;
          targetsOver = [];
          initialized = false;
        };

        function key(e) {
          if (win) { e = e || win.event; } // DOM0 used for arrow keys (should be changed)
          if (!e) { return true; }
          var k = getKeyboardKey(e);
          var co = [];

          switch(mode) {
          case 'size':
            if (!initialized) { initializeSize(); }
            c = getElementSizeStyle(elDrag);
            if (constrain) { co = getElementSize(elDrag); }
            break;
          case 'scroll':
            initialized = true;
            c = getElementScrollPosition(elDrag);
            break;
          case 'move':
            if (!initialized) { initializeMove(); }
            c = getElementPositionStyle(elDrag);
            if (targets || constrain) { co = getElementPosition(elDrag); }
          }

          if (e.type == 'keydown') {
            switch (k) {
            case 37:
              c[1] -= speed;
              co[1] -= speed;
              break;
            case 38:
              c[0] -= speed;
              co[0] -= speed;
              break;
            case 39:
              c[1] += speed;
              co[1] += speed;
              break;
            case 40:
              c[0] += speed;
              co[0] += speed;
              break;
            case 13:
              finish();
            }
            if (k != 13) {
              speed += accelerate;
              if (axes == 'vertical') { c[1] = null; }
              if (axes == 'horizontal') { c[0] = null; }
              if (callback(c, co)) {
                switch(mode) {
                case 'size':
                  if (c[0] < 0) { c[0] = 0; }
                  if (c[1] < 0) { c[1] = 0; }
                  sizeElement(elDrag, c[0], c[1]);
                  break;
                case 'scroll':
                  setElementScrollPosition(elDrag, scrollPos[0] + c[0] - mouse[0], scrollPos[1] + c[1] - mouse[1]);
                  break;
                case 'move':
                  positionElement(elDrag, c[0], c[1]);
                }
              }
              else {
                if (collision) { finish(); }
              }
            }
          }
          else {
            speed = oldSpeed;
          }
          return cancelDefault(e);
        }
        function cancel(e) { // DOM0 used for document mousedown event
          if (win) { e = e || win.event; }
          if (e) { cancelDefault(e); }
          return false;
        }
        function start(e, el, options, elHandle) {
          var d, mb, parent;

          keyboardOnly = options.keyboardOnly;

          mb = getMouseButtons(e);
          if (!keyboardOnly && (mb.right || mb.middle || mb.left) && !getMouseButtons(e)[options.button || 'left']) { return true; }

          //if (!keyboardOnly && !getMouseButtons(e)[options.button || 'left']) { return true; }
          elDrag = el;
          docNode = getElementDocument(el);
          win = (getDocumentWindow)?getDocumentWindow(docNode):null;
          if (!win && docNode == global.document) { win = global; } // TODO: Should generalize this logic in getDocumentWindow
          elDragHandle = elHandle;
          callbackContext = options.callbackContext || elDrag;
          ondraginit = options.ondraginit;
          ondragterminate = options.ondragterminate;
          ondragstart = options.ondragstart;
          ondrag = options.ondrag;
          ondragover = options.ondragover;
          ondragout = options.ondragout;
          ondrop = options.ondrop;
          if (typeof getElementPosition == 'function') {
            targets = options.targets;
            constrain = options.constrain;
          }
          else {
            targets = constrain = false;
          }
          targetObstacles = options.targetObstacles;
          collision = false;
          obstaclesFatal = options.obstaclesFatal;
          revert = options.revert;
          axes = options.axes;
          ghost = options.ghost;
          if (typeof ghost == 'undefined') { ghost = 0.5; }
          mode = options.mode || 'move';
          speed = oldSpeed = options.speed || 10;
          accelerate = options.accelerate || 1;

          if (constrain) {
            parent = getPositionedParent(el);
            if (parent) {
              d = getElementSize(parent);
              constraint = [0, 0, d[2], d[3]];
            }
            else {
              if (getViewportClientRectangle) { constraint = getViewportClientRectangle(); }
            }
          }
          oldStyle.position = elDrag.style.position;
          oldStyle.left = elDrag.style.left;
          oldStyle.top = elDrag.style.top;
          oldStyle.width = elDrag.style.width;
          oldStyle.height = elDrag.style.height;
          pos = getElementPositionStyle(elDrag);

          if (mode == 'size') { dim = getElementSizeStyle(elDrag); }
          if (targets || constrain) {
            posO = getElementPosition(elDrag);
            dimO = getElementSize(elDrag);
          }
          if (mode == 'scroll') { scrollPos = getElementScrollPosition(elDrag); }
          mouse = getMousePosition(e);
          if (!keyboardOnly) {
            attachListener(docNode, 'mousemove', (mode == 'size')?size:(mode == 'scroll')?scroll:drag);
            attachListener(docNode, 'mouseup', finish);
          }
          oldMouseDown = docNode.onmousedown;
          docNode.onmousedown = cancel;
          oldKeyDown = docNode.onkeydown;
          docNode.onkeydown = key;
          oldKeyUp = docNode.onkeyup;
          docNode.onkeyup = key;
          if (ondraginit) { callInContext(ondraginit, callbackContext, e); }
          return cancelDefault(e);
        }
        return function(el, elHandle, options) {
          options = options || {};
          var mode = options.mode || 'move';
          var listener, elTarget = elHandle || el;
          var uid = elementUniqueId(elTarget);
          if (!attachedDrag[uid] && (mode == 'move' && (isPositionable(el) || typeof absoluteElement == 'function') || (mode == 'size' && typeof getElementSizeStyle == 'function') || mode == 'scroll')) {
            listener = function(e) {
              if (elTarget == elDrag) { return; }
              if (elDrag) { finish(); } start(e, el, options, elHandle);
            };
            attachListener(elTarget, 'mousedown', listener);
            attachedDrag[uid] = listener;
            return true;
          }
          return false;
        };
      })();

      API.attachDrag = attachDrag;

      detachDrag = function(el, elHandle) {
        var elTarget = elHandle || el;
        var uid = elementUniqueId(elTarget);
        if (attachedDrag[uid]) {
          detachListener(elTarget, 'mousedown', attachedDrag[uid]);
          attachedDrag[uid] = null;
        }
      };

      API.detachDrag = detachDrag;
      }

      if (typeof fireEvent == 'function') {
        initiateDrag = function(el, elHandle, e) {
          fireEvent(elHandle || el, 'mousedown', null, e);
        };

        API.initiateDrag = initiateDrag;
      }

      if (canAdjustStyle) {

        // Defect test for getElementPositionStyle and getElementSizeStyle (Opera 9 is a known offender)
        if (body && getKomputedStyle && isHostMethod(body, 'appendChild') && typeof createElement == 'function') {
          div = createElement('div');
          if (div) {
            setStyles(div, {height:'0', width:'0', padding:'0', top:'0', left:'0', position:'absolute', visibility:'hidden', border:'solid 1px'});
            body.appendChild(div);
            computedSizeBad = (getKomputedStyle(div, 'height') == '2px');
            div2 = createElement('div');
            if (div2) {
              setStyles(div2, {margin:'0', position:'absolute'});
              div.appendChild(div2);
              computedPositionBad = (getKomputedStyle(div2, 'left') == '1px');
              body.removeChild(div);
              div2 = null;
            }
            div = null;
          }
        }

        // Returns dimensions suitable to pass to sizeElement
        // Works for browsers incapable of computing styles or broken in that regard

        getElementSizeStyle = function(el) {
          var dim = [];

          dim[0] = getStylePixels(el, 'height');
          dim[1] = getStylePixels(el, 'width');
          if ((dim[0] === null || dim[1] === null || computedSizeBad)) {
            if (typeof el.offsetHeight == 'number') {
              dim[0] = el.offsetHeight;
              dim[1] = el.offsetWidth;
              el.style.height = dim[0] + 'px';
              el.style.width = dim[1] + 'px';
              adjustElementSize(el, dim);
            }
            else {
              return null;
            }
          }
          return dim;
        };

        API.getElementSizeStyle = getElementSizeStyle;

        ensureSizable = function(el, display) {
          var d;
          if (typeof el.height != 'number') {
            d = getStyle(el, 'display');
            if (!d || d == 'inline') {
              if (typeof presentElement == 'function') {
                presentElement(el, true);
                if (el.style.display == 'inline') {
                  el.style.display = display || 'block';
                }
                return true;
              }
              return false;
            }
          }
          return true;
        };

        // Returns coordinates suitable to pass to positionElement
        // Works for browsers incapable of computing styles or broken in that regard

        getElementPositionStyle = (function() {
          var fix;

          if (body && typeof body.offsetLeft == 'number') {
            fix = function(el, y, x) {
              var oldX = el.offsetLeft;
              var oldY = el.offsetTop;
              positionElement(el, y, x);
              if (oldX != el.offsetLeft) { x -= (el.offsetLeft - oldX); }
              if (oldY != el.offsetTop) { y -= (el.offsetTop - oldY); }
              if (oldX != x || oldY != y) { positionElement(el, y, x); }
              return [y, x];
            };
          }

          return function(el, posParent) {
            var pos = getStyle(el, 'position');
            var x = getStylePixels(el, 'left');
            var y = getStylePixels(el, 'top');

            if (x !== null && y !== null && (!computedPositionBad || isPositionable(el))) {
              return (computedPositionBad && fix && (x + 'px' != el.style.left || y + 'px' != el.style.top))?fix(el, y, x):[y, x];
            }

            // Calculate offset from root element or positioned parent

            if (isRealObjectProperty(el, 'offsetParent') && typeof getElementPosition == 'function') {
              posParent = (typeof posParent == 'undefined')?getPositionedParent(el):posParent;
              if (!posParent && pos == 'relative') {
                x = y = 0;
              } else {
                var p = (posParent)?getElementPosition(el, posParent, true, posParent):getElementPosition(el, null, true, posParent);
                y = p[0];
                x = p[1];
              }
            } else {
              if (isPositionable(el)) {
                x = y = 0;
              }
              else {
                return null;
              }
            }
            return (fix)?fix(el, y, x):[y, x];
          };
        })();

        API.getElementPositionStyle = getElementPositionStyle;

        defaultDisplay = (function() {
          var reBlockDisplay, blockDisplay = 'ADDRESS|BLOCKQUOTE|BODY|DD|DIV|DL|DT|FIELDSET|FORM|IFRAME|I?FRAME|FRAMESET|H\\d|OL|P|UL|CENTER|DIR|HR|MENU|PRE', otherDisplayTypes = {};
          var elTable, el;

          if (body && getKomputedStyle && isHostMethod(body, 'appendChild') && typeof createElement == 'function') {
            el = createElement('div');
            if (el) {
              setStyles(el, {position:'absolute', left:'0', top:'0'});
              el.style.position = 'absolute';
              body.appendChild(el);
              elTable = createElement('table');
              if (elTable) {
                el.appendChild(elTable);
                if (getKomputedStyle(elTable, 'display') == 'block') {
                  blockDisplay += '|TABLE|TBODY|TH|TFOOT|TR|TD|COL.*|CAPTION|LI';
                }
                else {
                  otherDisplayTypes = {li:'list-item', table:'table', tbody:'table-row-group', tr:'table-row', td:'table-cell', th:'table-header-group', tfoot:'table-footer-group', caption:'table-caption', colgroup:'table-column-group', col:'table-column'};
                }
                body.removeChild(el);
                elTable = null;
                el = null;
              }
            }
          }
          reBlockDisplay = new RegExp('^(' + blockDisplay + ')$', 'i');
          return function(nn) {
            if (reBlockDisplay.test(nn)) { return 'block'; }
            return otherDisplayTypes[nn] || 'inline';
          };
        })();

        if (canAdjustStyle.display) {
          presentElement = function(el, b, display) {
            var d;

            if (typeof b == 'undefined') { b = true; }
            if (b) {
              if (display) {
                el.style.display = display;
              }
              else {
                el.style.display = '';
                if (getKomputedStyle) {
                  d = getKomputedStyle(el, display);
                  if (d && d != 'none') { return; }
                }
                el.style.display = defaultDisplay(getElementNodeName(el));
              }
            }
            else {
              el.style.display = 'none';
            }
          };
        }

        API.presentElement = presentElement;

        toggleElementPresence = function(el, display) {
          presentElement(el, !isPresent(el), display);
        };

        API.toggleElementPresence = toggleElementPresence;


        if (canAdjustStyle.position) {
          relativeElement = function(el, posParent) {
            var pos;
            posParent = (typeof posParent == 'undefined')?getPositionedParent(el):posParent;
            var p = getStyle(el, 'position');
            if (p != 'relative') {
              if (posParent) {
                pos = getElementPosition(el, posParent);
                positionElement(el, pos[0], pos[1]);
              }
              else {
                positionElement(el, 0, 0);
              }
              el.style.position = 'relative';
            }
          };

          API.relativeElement = relativeElement;

          absoluteElement = function(el, posParent) {
            posParent = (typeof posParent == 'undefined')?getPositionedParent(el):posParent;
            var pos = getElementPosition(el, posParent);
            var dim = getElementSizeStyle(el);
            var margins = (typeof getElementMarginsOrigin == 'function')?getElementMarginsOrigin(el):[0, 0];

            if (dim) { sizeElement(el, dim[0], dim[1]); }
            if (pos) { positionElement(el, pos[0] - margins[0], pos[1] - margins[1]); }
            el.style.position = 'absolute';
          };

          API.absoluteElement = absoluteElement;
        }

        ensurePositionable = function(el, posParent, position) {
          var p = getStyle(el, 'position');
          if (!p || p == 'static') {
            if (canAdjustStyle.position) {
              ((!position || position == 'absolute')?absoluteElement:relativeElement)(el, posParent);
              return true;
            }
            return false;
          }
          return true;
        };

        getElementPositionedChildPosition = function(el, elParent) {
          return (getStyle(el, 'position') == 'relative')?getElementPosition(el, elParent, true):getElementPositionStyle(el, elParent);
        };

        overlayElement = function(el, elOver, cover) {
          var pos, dim;
          var m = (typeof getElementMarginsOrigin == 'function')?getElementMarginsOrigin(el):[0, 0];
          var parent = getPositionedParent(el);
          var parentOver = getPositionedParent(elOver);

          if (!ensurePositionable(el, parent)) { return false; }
          if (parent) {
            if (parent === parentOver) {
              pos = getElementPositionedChildPosition(elOver, parentOver);
            }
            else {
              return false;
            }
          }
          else {
            // TODO: if el is fixed, check if over is in viewport, else fail
            pos = getElementPosition(elOver);
            var posStyle = getStyle(el, 'position');
            if (posStyle == 'fixed') {
              if (typeof getScrollPosition != 'undefined') {
                var docNode = getElementDocument(el);
                var sp = getScrollPosition(docNode);
                pos[0] -= sp[0];
                pos[1] -= sp[1];
              }
            }
          }
          if (cover) {
            dim = getElementSize(elOver);
            sizeElement(el, dim[0], dim[1]);
            adjustElementSize(el, dim);
          }
          positionElement(el, pos[0] - m[0], pos[1] - m[1]);
          return true;
        };

        API.overlayElement = overlayElement;

      }

      // Special Effects

      if (!canAdjustStyle) { return; }

      var EffectTimer, recordInlineStyles, restoreInlineStyles;
      var clip, drop;
      var oldPositionElement, oldCenterElement, oldMaximizeElement, oldRestoreElement, oldChangeImage, oldSetElementHtml, oldSetElementNodes, oldShowElement, oldSizeElement;
      var ensurePresent = function(el, display) {
        if (!isPresent(el)) {
          if (typeof presentElement == 'function') {
            presentElement(el, true, display);
            return isPresent(el);
          }
          return false;
        }
        return true;
      };

      EffectTimer = function(options) {
        var el, fn, bIn, dir, rpt, revert, duration, ease, cb, cbBounce, cbBeforeDone, pt, ptTemp, fps, interval, started, f, t, p, e, a;
        var myOptions = options || {};

        function processFunctions(prog, endCode) {
          fn(el, prog, pt, endCode);
        }

        function clearInterval() {
          global.clearInterval(interval);
          interval = 0;
        }

        function finish(interrupt) {
          clearInterval();
          if ((!cbBeforeDone || !cbBeforeDone(el, interrupt)) && (interrupt || revert)) { processFunctions((bIn)?t:f, (revert)?3:2); }
          if (cb) { cb(el, interrupt); }
        }

        function repeat() {
          if (--rpt) {
            if (dir == 'inandout' || dir == 'outandin') { bIn = !bIn; }
            started = new Date();
          }
          else {
            finish();
          }
        }

        function bounce() {
          if ((dir == 'inandout' && bIn) || (dir == 'outandin' && !bIn)) {
            processFunctions(e * (t - f));
            bIn = !bIn;
            if (cbBounce) { cbBounce(el, rpt); }
            started = new Date();
          }
          else {
            finish();
          }
        }

        function process() {
          p = ((new Date() - started) / duration);
          if (p > 1) { p = 1; }
          e = p;
          if (!bIn) { e = 1 - e; }
          if (ease && p < 1) { e = ease(e); }
          processFunctions(e * (t - f));
          if (p == 1) {
            if (dir == 'in' || dir == 'out' || (dir == 'inandout' && !bIn) || (dir == 'outandin' && bIn)) {
              repeat();
            }
            else {
              bounce();
            }
          }
        }

        function interrupt() {
          finish(true);
        }

        function getOption(options, name) {
          return (typeof options[name] == 'undefined')?myOptions[name]:options[name];
        }

        function fnCombineEffect(fn1, fn2) {
          return function(el, prog, pt, endCode) { fn1(el, prog, pt, endCode); fn2(el, prog, pt, endCode); };
        }

        this.start = function(element, options, fnDone, fnBounce, fnBeforeDone) {
          var index;
          if (interval) { interrupt(); }
          options = options || {};
          el = element;
          f = getOption(options, 'from') || 0;
          t = getOption(options, 'to') || 1;
          dir = (options.dir || 'in').toLowerCase();
          bIn = dir != 'out' && dir != 'outandin';
          duration = getOption(options, 'duration');
          ease = getOption(options, 'ease');
          cb = fnDone;
          cbBounce = fnBounce;
          cbBeforeDone = fnBeforeDone;
          pt = {};
          ptTemp = getOption(options, 'effectParams');
          if (ptTemp) { // Copy effect workspace
            for (index in ptTemp) {
              if (isOwnProperty(ptTemp, index)) {
                pt[index] = ptTemp[index];
              }
            }
          }
          revert = getOption(options, 'revert');
          a = getOption(options, 'effects');
          if (typeof a != 'function') {
            index = a.length;
            while (index--) { fn = (fn)?fnCombineEffect(fn, a[index]):a[index]; }
          }
          else {
            fn = a;
          }
          fps = getOption(options, 'fps') || 30;
          started = new Date();
          rpt = getOption(options, 'repeat') || 1;
          interval = global.setInterval(process, 1000 / fps);
          processFunctions((bIn)?f:t, 1);
        };

        this.stop = function(complete) { if (complete) { bIn = (dir == 'in' || dir == 'outandin'); interrupt(); } else { finish(); } };
        this.busy = function() { return !!interval; };
      };

      API.EffectTimer = EffectTimer;

      recordInlineStyles = function(el, styles, scratch) {
        var i = styles.length;
        while (i--) { scratch[styles[i]] = el.style[styles[i]]; }
      };

      restoreInlineStyles = function(el, styles, scratch) {
        var i = styles.length;
        while (i--) { el.style[styles[i]] = scratch[styles[i]]; }
      };

      if (typeof showElement == 'function') {
        oldShowElement = showElement;

	showElement = API.showElement = (function() {
          var activeEffects = {};
          var cb = {};

          function finish(el, b, options) {
            if (!b && (options && options.removeOnHide) && typeof presentElement == 'function') { presentElement(el, false); }
          }

          return function(el, b, options, fnDone) {
            var effect, fnDoneInternal, fnBeforeDone, uid;

            options = options || {};

            uid = elementUniqueId(el);
            if (activeEffects[uid]) {
              activeEffects[uid].stop(true);
              presentElement(el, options.display);
            }

            if (options.effects) {
              effect = new EffectTimer();
              options.dir = (b)?'in':'out';
              options.revert = true;
              cb[uid] = fnDone;
              if (ensurePresent(el, options.display)) {
                fnDoneInternal = function(el, interrupt) {
                  finish(el, b, options);
                  effect = null;
                  activeEffects[uid] = null;
                  if (cb[uid]) { cb[uid](el, b); }
                };
                fnBeforeDone = function(el, interrupt) {
                  if (!b && !interrupt) { oldShowElement(el, false); }
                };
                activeEffects[uid] = effect;
                effect.start(el, options, fnDoneInternal, null, fnBeforeDone);
              }
            }
            else {
              oldShowElement(el, b, options);
              if (fnDone) { fnDone(); }
            }
            return el;
          };
	})();

        toggleElement = API.toggleElement = function(el, options, fnDone) {
          return showElement(el, !isVisible(el) || !isPresent(el), options, fnDone);
        };

        showElement.async = true;
        toggleElement.async = true;
      }

      if (typeof sizeElement == 'function') {
        oldSizeElement = sizeElement;
        sizeElement = (function() {
          var activeEffects = {};
          var cb = {};
          return function(el, h, w, options, fnDone) {
            var effect, fnDoneInternal, pt, uid;
            if (options && options.duration) {
              uid = elementUniqueId(el);
              if (activeEffects[uid]) { activeEffects[uid].stop(true);}
              effect = new EffectTimer();
              options.effects = effects.grow;
              pt = options.effectParams || {};
              pt.targetSize = [h, w];
              options.effectParams = pt;
              cb[elementUniqueId(el)] = fnDone;
              fnDoneInternal = function() {
                effect = null;
                activeEffects[uid] = null;
                if (cb[uid]) { cb[uid](el); }
              };
              activeEffects[uid] = effect;
              effect.start(el, options, fnDoneInternal);
            }
            else {
              oldSizeElement(el, h, w);
              if (fnDone) { fnDone(el); }
            }
          };
        })();
        sizeElement.async = true;
        API.sizeElement = sizeElement;
      }

      if (typeof positionElement == 'function') {
        oldPositionElement = positionElement;

        positionElement = (function() {
          var activeEffects = {};
          var cb = {};
          return function(el, t, l, options, fnDone) {
            var effect, fnDoneInternal, pt, uid;
            if (options && options.duration) {
              uid = elementUniqueId(el);
              if (activeEffects[uid]) { activeEffects[uid].stop(true);}
              effect = new EffectTimer();
              options.effects = effects.move;
              pt = options.effectParams || {};
              pt.targetPosition = [t, l];
              options.effectParams = pt;
              cb[uid] = fnDone;
              fnDoneInternal = function(el, interrupt) {
                effect = null;
                activeEffects[uid] = null;
                if (cb[uid]) { cb[uid](el, interrupt); }
              };
              activeEffects[uid] = effect;
              effect.start(el, options, fnDoneInternal);
            }
            else {
              oldPositionElement(el, t, l);
              if (fnDone) { fnDone(el); }
            }
          };
        })();

        positionElement.async = true;
        API.positionElement = positionElement;
      }

      effects = {};

      if (typeof setOpacity == 'function') {
        effects.fade = function(el, p, scratch, endCode) {
          if (endCode) {
            if (endCode > 2) {
                p = (typeof scratch.targetOpacity != 'undefined')?0:1;
            }
            if (endCode == 2) { p = 1; }
            if (endCode == 1) {
              scratch.opacity = getOpacity(el) || 1;
              if (scratch.opacity >= 0.9999) { scratch.opacity = 1; }
              if (canAdjustStyle.visibility) { el.style.visibility = 'visible'; }
            }
          }
          p = (typeof scratch.targetOpacity != 'undefined')?scratch.opacity + (scratch.targetOpacity - scratch.opacity) * p:scratch.opacity * p;
          setOpacity(el, (p >= 1)?0.9999:p); // Some versions of Firefox blink on 1
        };
      }

      drop = function(side, pos, dim, p) {
        var y, x, h, w;
        y = pos[0];
        x = pos[1];
        h = dim[0];
        w = dim[1];
        switch(side) {
        case 'left':
          x = ((x + w) - (p * w));
          break;
        case 'top':
          y = ((y + h) - (p * h));
          break;
        case 'diagonalsw':
          y = ((y + h) - (p * h));
          x = ((x - w) + (p * w));
          break;
        case 'diagonalnw':
          y = ((y - h) + (p * h));
          x = ((x - w) + (p * w));
          break;
        case 'diagonalse':
          y = ((y + h) - (p * h));
          x = ((x + w) - (p * w));
          break;
        case 'diagonalne':
          y = ((y - h) + (p * h));
          x = ((x + w) - (p * w));
          break;
        case 'bottom':
          y = ((y - h) + (p * h));
          break;
        default:
          x = ((x - w) + (p * w));
        }
	return [y, x];
      };

      clip = function(side, dim, p) {
        var h = dim[0];
        var w = dim[1];
        switch(side) {
        case 'top':
          return "rect(0px " + w + "px " + Math.round(p * h) + "px 0px)";
        case 'left':
          return "rect(0px " + Math.round(p * w) + "px " + h + "px 0px)";
        case 'zoom':
          return "rect(" + Math.round(((1 - p) / 2) * h) + "px " + Math.round((p / 2) * w + w / 2) + "px " + Math.round((p / 2) * h + h / 2) +  "px " + Math.round(((1 - p) / 2) * w) + "px)";
        case 'horizontal':
          return "rect(" + (Math.round(((1 - p) / 2) * h)) + "px " + w + "px " + Math.round((p / 2) * h + h / 2) + "px 0px)";
        case 'vertical':
          return "rect(0px " + Math.round((p / 2) * w + w/2) + "px " + h +  "px " + (Math.round(((1 - p) / 2) * w)) + "px)";
        case 'diagonalnw':
          return "rect(" + Math.round((1 - p) * h) + "px " + w + "px " + h + "px " + Math.round((1 - p) * w) + "px)";
        case 'diagonalne':
          return "rect(" + Math.round((1 - p) * h) + "px " + Math.round(p * w) + "px " + h + "px 0px)";
        case 'diagonalsw':
          return "rect(0px " + w + "px " + Math.round(p * h) + "px " + Math.round((1 - p) * w) + "px)";
        case 'diagonalse':
          return "rect(0px " + Math.round(p * w) + "px " + Math.round(p * h) + "px 0px)";
        case 'bottom':
          return "rect(" + Math.round((1 - p) * h) + "px " + w + "px " + h + "px 0px)";
        default:
          return "rect(0px " + w + "px " + h + "px " + Math.round((1 - p) * w) + "px)";
        }
      };

      if (typeof oldPositionElement == 'function') {
        effects.drop = (function() {
          var posNew;
          return function(el, p, scratch, endCode) {
            if (endCode) {
              if (endCode > 2) {
                restoreInlineStyles(el, ['top', 'left', 'position'], scratch);
                return;
              }
              if (endCode == 1) {
                recordInlineStyles(el, ['top', 'left', 'position'], scratch);
                if (typeof ensurePositionable == 'undefined' || ensurePositionable(el)) {
                  if (!scratch.dimOuter) { scratch.dimOuter = getElementSize(el); }
                  if (!scratch.pos) { scratch.pos = getElementPositionStyle(el); }
                }
                else {
                  scratch.pos = null;
                }
                if (canAdjustStyle.visibility) { el.style.visibility = 'visible'; }
              }
            }
            if (scratch.pos) {
              posNew = drop(scratch.side, scratch.pos, scratch.dimOuter, p);
              oldPositionElement(el, posNew[0], posNew[1]);
            }
          };
        })();
      }

      if (typeof oldSizeElement == 'function') {
        effects.grow = (function() {
          var axes, h, w;
          var reUnits = new RegExp('(.+)(em|px|pt|%)');

          function getFont(el) {
            var match;
            var font = getInlineStyle(el, 'fontSize') || getStyle(el, 'fontSize');

            if (font) {
              match = font.match(reUnits);
            }

            return match && { size:parseFloat(match[1]), unit:match[2] };
          }

          return function(el, p, scratch, endCode) {
            if (endCode) {
              if (endCode > 2) {
                restoreInlineStyles(el, ['overflow', 'fontSize', 'height', 'width'], scratch);
                return;
              }
              if (endCode == 1) {
                recordInlineStyles(el, ['overflow', 'fontSize', 'height', 'width'], scratch);
                el.style.overflow = 'hidden';
                if (ensureSizable(el)) {
                  if (!scratch.dim) { scratch.dim = getElementSizeStyle(el); }
                }
                else {
                  scratch.dim = null;
                }
                if (getKomputedStyle) { scratch.font = getFont(el); }
                if (canAdjustStyle.visibility) { el.style.visibility = 'visible'; }
              }
            }

            if (scratch.dim) {
              if (scratch.targetSize) {
                h = (scratch.dim[0] + (scratch.targetSize[0] - scratch.dim[0]) * p);
                w = (scratch.dim[1] + (scratch.targetSize[1] - scratch.dim[1]) * p);
              }
              else {
                axes = scratch.axes;
                h = (!axes || axes == 1)?scratch.dim[0] * p:null;
                w = (!axes || axes == 2)?scratch.dim[1] * p:null;
                if (!axes && scratch.font && p >= 0) { el.style.fontSize = (scratch.font.size * p) + scratch.font.unit; }
              }
              oldSizeElement(el, (h < 0)?null:h, (w < 0)?null:w);
            }
          };
	})();

        effects.fold = function(el, p, scratch, endCode) {
          if (endCode == 1) { scratch.axes = scratch.axes || 2; }
          effects.grow(el, p, scratch, endCode);
        };
      }

      // TODO: Detect clip style

      if (API.unclipElement) { // Add-on as function has conditional compilation, which fouls up minification
        effects.clip = (function() {
          return function(el, p, scratch, endCode) {
            if (endCode) {
              if (endCode > 2) {
                restoreInlineStyles(el, ['overflow', 'position'], scratch);
                API.unclipElement(el);
                return;
              }
              if (endCode == 1) {
                recordInlineStyles(el, ['overflow', 'position'], scratch);
                el.style.overflow = 'hidden';
                if (typeof ensurePositionable == 'function') { ensurePositionable(el); }
                if (!scratch.dimOuter) { scratch.dimOuter = getElementSize(el); }
                if (canAdjustStyle.visibility) { el.style.visibility = 'visible'; }
              }
            }
            el.style.clip = clip(scratch.side, scratch.dimOuter, p);
          };
        })();

        effects.zoom = function(el, p, scratch, endCode) {
          if (endCode == 1) { scratch.side = 'zoom'; }
          effects.clip(el, p, scratch, endCode);
        };

        effects.horizontalBlinds = function(el, p, scratch, endCode) {
          if (endCode == 1) { scratch.side = 'horizontal'; }
          effects.clip(el, p, scratch, endCode);
        };

        effects.verticalBlinds = function(el, p, scratch, endCode) {
          if (endCode == 1) { scratch.side = 'vertical'; }
          effects.clip(el, p, scratch, endCode);
	};

        if (typeof oldPositionElement == 'function') {
          effects.slide = (function() {
            var posNew;
            return function(el, p, scratch, endCode) {
              if (endCode) {
                if (endCode > 2) {
                  restoreInlineStyles(el, ['overflow', 'top', 'left', 'position'], scratch);
                  API.unclipElement(el);
                  return;
                }
                if (endCode == 1) {
                  recordInlineStyles(el, ['overflow', 'top', 'left', 'position'], scratch);
                  el.style.overflow = 'hidden';
                  if (typeof ensurePositionable == 'undefined' || ensurePositionable(el)) {
                    if (!scratch.dimOuter) { scratch.dimOuter = getElementSize(el); }
                    if (!scratch.pos) { scratch.pos = getElementPositionStyle(el); }
                  }
                  else {
                    scratch.pos = null;
                  }
                  if (canAdjustStyle.visibility) { el.style.visibility = 'visible'; }
                }
              }
              if (scratch.pos) {
                posNew = drop(scratch.side, scratch.pos, scratch.dimOuter, p);
                oldPositionElement(el, posNew[0], posNew[1]);
                el.style.clip = clip(scratch.side, scratch.dimOuter, p);
              }
            };
          })();
        }
      }


      if (typeof oldPositionElement == 'function') {
        effects.move = function(el, p, scratch, endCode) {
          if (endCode) {
            if (endCode > 2) {
              if (scratch.pos) { oldPositionElement(el, scratch.pos[0], scratch.pos[1]); }
              return;
            }
            if (endCode == 1) {
              if (typeof ensurePositionable == 'undefined' || ensurePositionable(el)) {
                if (!scratch.pos) { scratch.pos = getElementPositionStyle(el); }
                if (scratch.pos) {
                  if (scratch.targetPosition[0] === null) { scratch.targetPosition[0] = scratch.pos[0]; }
                  if (scratch.targetPosition[1] === null) { scratch.targetPosition[1] = scratch.pos[1]; }
                }
              }
              else {
                scratch.pos = null;
              }
            }
          }
          if (scratch.pos) { oldPositionElement(el, (scratch.pos[0] + ((scratch.targetPosition[0] - scratch.pos[0]) * p)), (scratch.pos[1] + ((scratch.targetPosition[1] - scratch.pos[1]) * p))); }
	};

        if (typeof maximizeElement == 'function') {
          oldMaximizeElement = maximizeElement;
          oldRestoreElement = restoreElement;
          maximizeElement = API.maximizeElement = function(el, options, fnDone) {
            var l, t, h, r, w, oldT, oldL, oldH, oldW, oldV, oldP;
            if (options) {
              oldT = el.style.top;
              oldL = el.style.left;
              oldH = el.style.height;
              oldW = el.style.width;
              oldV = el.style.visibility;
              oldP = el.style.position;
              el.style.visibility = 'hidden';
              r = oldMaximizeElement(el);
              if (oldP == el.style.position) {
                t = getStylePixels(el, 'top');
                l = getStylePixels(el, 'left');
                h = getStylePixels(el, 'height');
                w = getStylePixels(el, 'width');
                el.style.top = oldT;
                el.style.left = oldL;
                el.style.height = oldH;
                el.style.width = oldW;
                el.style.visibility = oldV;
                positionElement(el, t, l, options, fnDone);
                sizeElement(el, h, w, options, fnDone);
              }
              else {
                el.style.visibility = oldV;
                if (fnDone) { fnDone(el); }
              }
            }
            else {
              r = oldMaximizeElement(el);
              if (fnDone) { fnDone(el); }
            }
            return r;
          };
          maximizeElement.async = true;
          restoreElement = API.restoreElement = function(el, options, fnDone) {
            var a, l, t, h, r, w, oldT, oldL, oldH, oldW, oldV, oldP;
            if (options) {
              oldT = el.style.top;
              oldL = el.style.left;
              oldH = el.style.height;
              oldW = el.style.width;
              oldV = el.style.visibility;
              oldP = el.style.position;
              el.style.visibility = 'hidden';
              r = oldRestoreElement(el);
              if (oldP == el.style.position) {
                t = getStylePixels(el, 'top');
                l = getStylePixels(el, 'left');
		a = getElementSizeStyle(el);
		h = a[0];
		w = a[1];
                el.style.top = oldT;
                el.style.left = oldL;
                el.style.height = oldH;
                el.style.width = oldW;
                el.style.visibility = oldV;
                positionElement(el, t, l, options, fnDone);
                sizeElement(el, h, w, options, fnDone);
              }
              else {
                el.style.visibility = oldV;
                if (fnDone) { fnDone(el); }
              }
            }
            else {
              r = oldRestoreElement(el);
              if (fnDone) { fnDone(el); }
            }
            return r;
          };
          restoreElement.async = true;
        }

        if (typeof centerElement == 'function') {
          oldCenterElement = centerElement;
          centerElement = API.centerElement = function(el, options, fnDone) {
            var l, t, oldL, oldT, oldV, oldP;
            if (options) {
              oldT = el.style.top;
              oldL = el.style.left;
              oldV = el.style.visibility;
              oldP = el.style.position;
              el.style.visibility = 'hidden';
              oldCenterElement(el);
              t = getStylePixels(el, 'top');
              l = getStylePixels(el, 'left');
              el.style.top = oldT;
              el.style.left = oldL;
              el.style.visibility = oldV;
              if (oldP == el.style.position) {
                positionElement(el, t, l, options, fnDone);
                return;
              }
            }
            oldCenterElement(el);
            if (fnDone) { fnDone(el); }
          };
          centerElement.async = true;

          if (effects.grow && typeof overlayElement == 'function' && typeof showElement == 'function') {
            spring = function(el, elFrom, b, options, callback) {
              var pos, posOld, optionsNew = { duration:options.duration, ease:options.ease, removeOnHide:options.removeOnHide };
              if (options.effects && typeof options.effects == 'function') {
                optionsNew.effects = [options.effects];
              }
              else {
                optionsNew.effects = (options.effects || []).concat([effects.grow]);
              }
              if (b) {
		pos = getElementPositionStyle(el);
                overlayElement(el, elFrom);
		if (options.springMode == 'center') {
			centerElement(el, { duration:options.duration, ease:options.ease });
		}
		else {
			positionElement(el, pos[0], pos[1], { duration:options.duration, ease:options.ease });
		}
              }
              else {
                posOld = getElementPositionStyle(el);
                el.style.visibility = 'hidden';
                overlayElement(el, elFrom);
                pos = getElementPositionStyle(el);
                positionElement(el, posOld[0], posOld[1]);
                el.style.visibility = 'visible';
                positionElement(el, pos[0], pos[1], { duration:options.duration, ease:options.ease, revert:true });
              }
              showElement(el, b, optionsNew, callback);
            };

            API.spring = spring;
          }
        }

        effects.shake = function(el, p, scratch, endCode) {
          if (endCode) {
            if (endCode > 2) {
              restoreInlineStyles(el, ['top', 'left', 'position'], scratch);
              return;
            }
            if (endCode == 1) {
              recordInlineStyles(el, ['top', 'left', 'position'], scratch);
              if (typeof ensurePositionable == 'undefined' || ensurePositionable(el)) {
                if (!scratch.pos) { scratch.pos = getElementPositionStyle(el); }
              }
              else {
                scratch.pos = null;
              }
              scratch.severity = scratch.severity || 5;
              if (canAdjustStyle.visibility) { el.style.visibility = 'visible'; }
            }
          }
          if (scratch.pos) { oldPositionElement(el, scratch.pos[0] + (!scratch.axes || scratch.axes == 1)?(scratch.severity - Math.floor(Math.random() * (scratch.severity * 2 + 1))):0, scratch.pos[1] + (!scratch.axes || scratch.axes == 2)?(scratch.severity - Math.floor(Math.random() * (scratch.severity * 2 + 1))):0); }
	};
      }

      API.effects = effects;

      API.ease = {};

      API.ease.sine = function(p) {
        return (Math.sin(p * Math.PI / 2));
      };

      API.ease.cosine = function(p) {
        return ((-Math.cos(p * Math.PI) / 2) + 0.5);
      };

      API.ease.tan = function(p) {
        var tan = Math.tan;
        return (tan(1*(2*p-1))/tan(1)+1)/2;
      };

      API.ease.flicker = function(p) {
        return ((-Math.cos(p * Math.PI) / 4) + 0.75) + Math.random() * 0.25;
      };

      API.ease.wobble = function(p) {
        return (-Math.cos(p * Math.PI * (9 * p)) / 2) + 0.5;
      };

      API.ease.square = function(p) {
        return(Math.pow(p, 2));
      };

      API.ease.circle = function(p) {
        return Math.sqrt(1 - Math.pow((p - 1), 2));
      };

      API.ease.pulsate = function(p) {
        return (0.5 + Math.sin(17 * p) / 2);
      };

      API.ease.expo = function(p) {
        return Math.pow(2, 8 * (p - 1));
      };

      API.ease.quad = function(p) {
        return Math.pow(p, 2);
      };

      API.ease.cube = function(p) {
        return Math.pow(p, 3);
      };

      // Sigmoid functions based upon work by Emmanuel Pietriga.
      // http://www.docjar.net/html/api/com/xerox/VTM/engine/AnimManager.java.html
      // Copyright (c) Xerox Corporation, XRCE/Contextual Computing, 2002.

      API.ease.sigmoid = function(p, steepness) { // Currently no way to pass second parameter to easing function
        var atan = Math.atan;
        steepness = steepness || 1;
        return (atan(steepness*(2*p-1))/atan(steepness)+1)/2;
      };

      API.ease.sigmoid2 = function(p) {
        var atan = Math.atan;
        return (atan(2*(2*p-1))/atan(2)+1)/2;
      };

      API.ease.sigmoid3 = function(p) {
        var atan = Math.atan;
        return (atan(3*(2*p-1))/atan(3)+1)/2;
      };

      API.ease.sigmoid4 = function(p) {
        var atan = Math.atan;
        return (atan(4*(2*p-1))/atan(4)+1)/2;
      };

      API.ease.loop = function(p) {
        return (-Math.cos(2*p*Math.PI)/2) + 0.5;
      };

      API.ease.bounce = function(p) {
        return 1 - (Math.cos(p * 4.5 * Math.PI) * Math.exp(-p * 6));
      };

      // Based on Easing Equations v2.0
      // (c) 2003 Robert Penner, all rights reserved.
      // This work is subject to the terms in http://www.robertpenner.com/easing_terms_of_use.html

      API.ease.swingTo = function(p) {
        var s = 1.70158;
        return (p-=1)*p*((s+1)*p + s) + 1;
      };

      API.ease.swingToFrom = function(p) {
        var s = 1.70158;
        if ((p/=0.5) < 1) { return 0.5*(p*p*(((s*=(1.525))+1)*p - s)); }
        return 0.5*((p-=2)*p*(((s*=(1.525))+1)*p + s) + 2);
      };


      body = containerElement = null;
    });

  }

  doc = null;
  html = null;
})();
